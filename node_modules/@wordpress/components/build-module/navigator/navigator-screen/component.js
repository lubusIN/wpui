import { createElement } from "@wordpress/element";
function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports
import { motion } from 'framer-motion';
import { css } from '@emotion/react';

/**
 * WordPress dependencies
 */
import { focus } from '@wordpress/dom';
import { useContext, useEffect, useMemo, useRef, useId } from '@wordpress/element';
import { useReducedMotion, useMergeRefs } from '@wordpress/compose';
import { isRTL } from '@wordpress/i18n';
import { escapeAttribute } from '@wordpress/escape-html';

/**
 * Internal dependencies
 */

import { contextConnect, useContextSystem } from '../../ui/context';
import { useCx } from '../../utils/hooks/use-cx';
import { View } from '../../view';
import { NavigatorContext } from '../context';
const animationEnterDelay = 0;
const animationEnterDuration = 0.14;
const animationExitDuration = 0.14;
const animationExitDelay = 0;

// Props specific to `framer-motion` can't be currently passed to `NavigatorScreen`,
// as some of them would overlap with HTML props (e.g. `onAnimationStart`, ...)
var _ref = process.env.NODE_ENV === "production" ? {
  name: "14x3t6z",
  styles: "overflow-x:auto;max-height:100%"
} : {
  name: "1ulogbc-classes",
  styles: "overflow-x:auto;max-height:100%;label:classes;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1zY3JlZW4vY29tcG9uZW50LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE0RUkiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9uYXZpZ2F0b3IvbmF2aWdhdG9yLXNjcmVlbi9jb21wb25lbnQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBGb3J3YXJkZWRSZWYgfSBmcm9tICdyZWFjdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgdHlwZSB7IE1vdGlvblByb3BzIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tICdmcmFtZXItbW90aW9uJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGZvY3VzIH0gZnJvbSAnQHdvcmRwcmVzcy9kb20nO1xuaW1wb3J0IHtcblx0dXNlQ29udGV4dCxcblx0dXNlRWZmZWN0LFxuXHR1c2VNZW1vLFxuXHR1c2VSZWYsXG5cdHVzZUlkLFxufSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuaW1wb3J0IHsgdXNlUmVkdWNlZE1vdGlvbiwgdXNlTWVyZ2VSZWZzIH0gZnJvbSAnQHdvcmRwcmVzcy9jb21wb3NlJztcbmltcG9ydCB7IGlzUlRMIH0gZnJvbSAnQHdvcmRwcmVzcy9pMThuJztcbmltcG9ydCB7IGVzY2FwZUF0dHJpYnV0ZSB9IGZyb20gJ0B3b3JkcHJlc3MvZXNjYXBlLWh0bWwnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBjb250ZXh0Q29ubmVjdCwgdXNlQ29udGV4dFN5c3RlbSB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgdXNlQ3ggfSBmcm9tICcuLi8uLi91dGlscy9ob29rcy91c2UtY3gnO1xuaW1wb3J0IHsgVmlldyB9IGZyb20gJy4uLy4uL3ZpZXcnO1xuaW1wb3J0IHsgTmF2aWdhdG9yQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHR5cGUgeyBOYXZpZ2F0b3JTY3JlZW5Qcm9wcyB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgYW5pbWF0aW9uRW50ZXJEZWxheSA9IDA7XG5jb25zdCBhbmltYXRpb25FbnRlckR1cmF0aW9uID0gMC4xNDtcbmNvbnN0IGFuaW1hdGlvbkV4aXREdXJhdGlvbiA9IDAuMTQ7XG5jb25zdCBhbmltYXRpb25FeGl0RGVsYXkgPSAwO1xuXG4vLyBQcm9wcyBzcGVjaWZpYyB0byBgZnJhbWVyLW1vdGlvbmAgY2FuJ3QgYmUgY3VycmVudGx5IHBhc3NlZCB0byBgTmF2aWdhdG9yU2NyZWVuYCxcbi8vIGFzIHNvbWUgb2YgdGhlbSB3b3VsZCBvdmVybGFwIHdpdGggSFRNTCBwcm9wcyAoZS5nLiBgb25BbmltYXRpb25TdGFydGAsIC4uLilcbnR5cGUgUHJvcHMgPSBPbWl0PFxuXHRXb3JkUHJlc3NDb21wb25lbnRQcm9wczwgTmF2aWdhdG9yU2NyZWVuUHJvcHMsICdkaXYnLCBmYWxzZSA+LFxuXHRFeGNsdWRlPCBrZXlvZiBNb3Rpb25Qcm9wcywgJ3N0eWxlJyB8ICdjaGlsZHJlbicgPlxuPjtcblxuZnVuY3Rpb24gVW5jb25uZWN0ZWROYXZpZ2F0b3JTY3JlZW4oXG5cdHByb3BzOiBQcm9wcyxcblx0Zm9yd2FyZGVkUmVmOiBGb3J3YXJkZWRSZWY8IGFueSA+XG4pIHtcblx0Y29uc3Qgc2NyZWVuSWQgPSB1c2VJZCgpO1xuXHRjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHBhdGgsIC4uLm90aGVyUHJvcHMgfSA9IHVzZUNvbnRleHRTeXN0ZW0oXG5cdFx0cHJvcHMsXG5cdFx0J05hdmlnYXRvclNjcmVlbidcblx0KTtcblxuXHRjb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb24oKTtcblx0Y29uc3QgeyBsb2NhdGlvbiwgbWF0Y2gsIGFkZFNjcmVlbiwgcmVtb3ZlU2NyZWVuIH0gPVxuXHRcdHVzZUNvbnRleHQoIE5hdmlnYXRvckNvbnRleHQgKTtcblx0Y29uc3QgaXNNYXRjaCA9IG1hdGNoID09PSBzY3JlZW5JZDtcblx0Y29uc3Qgd3JhcHBlclJlZiA9IHVzZVJlZjwgSFRNTERpdkVsZW1lbnQgPiggbnVsbCApO1xuXG5cdHVzZUVmZmVjdCggKCkgPT4ge1xuXHRcdGNvbnN0IHNjcmVlbiA9IHtcblx0XHRcdGlkOiBzY3JlZW5JZCxcblx0XHRcdHBhdGg6IGVzY2FwZUF0dHJpYnV0ZSggcGF0aCApLFxuXHRcdH07XG5cdFx0YWRkU2NyZWVuKCBzY3JlZW4gKTtcblx0XHRyZXR1cm4gKCkgPT4gcmVtb3ZlU2NyZWVuKCBzY3JlZW4gKTtcblx0fSwgWyBzY3JlZW5JZCwgcGF0aCwgYWRkU2NyZWVuLCByZW1vdmVTY3JlZW4gXSApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oXG5cdFx0KCkgPT5cblx0XHRcdGN4KFxuXHRcdFx0XHRjc3MoIHtcblx0XHRcdFx0XHQvLyBFbnN1cmVzIGhvcml6b250YWwgb3ZlcmZsb3cgaXMgdmlzdWFsbHkgYWNjZXNzaWJsZS5cblx0XHRcdFx0XHRvdmVyZmxvd1g6ICdhdXRvJyxcblx0XHRcdFx0XHQvLyBJbiBjYXNlIHRoZSByb290IGhhcyBhIGhlaWdodCwgaXQgc2hvdWxkIG5vdCBiZSBleGNlZWRlZC5cblx0XHRcdFx0XHRtYXhIZWlnaHQ6ICcxMDAlJyxcblx0XHRcdFx0fSApLFxuXHRcdFx0XHRjbGFzc05hbWVcblx0XHRcdCksXG5cdFx0WyBjbGFzc05hbWUsIGN4IF1cblx0KTtcblxuXHRjb25zdCBsb2NhdGlvblJlZiA9IHVzZVJlZiggbG9jYXRpb24gKTtcblxuXHR1c2VFZmZlY3QoICgpID0+IHtcblx0XHRsb2NhdGlvblJlZi5jdXJyZW50ID0gbG9jYXRpb247XG5cdH0sIFsgbG9jYXRpb24gXSApO1xuXG5cdC8vIEZvY3VzIHJlc3RvcmF0aW9uXG5cdGNvbnN0IGlzSW5pdGlhbExvY2F0aW9uID0gbG9jYXRpb24uaXNJbml0aWFsICYmICEgbG9jYXRpb24uaXNCYWNrO1xuXHR1c2VFZmZlY3QoICgpID0+IHtcblx0XHQvLyBPbmx5IGF0dGVtcHQgdG8gcmVzdG9yZSBmb2N1czpcblx0XHQvLyAtIGlmIHRoZSBjdXJyZW50IGxvY2F0aW9uIGlzIG5vdCB0aGUgaW5pdGlhbCBvbmUgKHRvIGF2b2lkIG1vdmluZyBmb2N1cyBvbiBwYWdlIGxvYWQpXG5cdFx0Ly8gLSB3aGVuIHRoZSBzY3JlZW4gYmVjb21lcyB2aXNpYmxlXG5cdFx0Ly8gLSBpZiB0aGUgd3JhcHBlciByZWYgaGFzIGJlZW4gYXNzaWduZWRcblx0XHQvLyAtIGlmIGZvY3VzIGhhc24ndCBhbHJlYWR5IGJlZW4gcmVzdG9yZWQgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uXG5cdFx0Ly8gLSBpZiB0aGUgYHNraXBGb2N1c2Agb3B0aW9uIGlzIG5vdCBzZXQgdG8gYHRydWVgLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdlIHRyaWdnZXIgdGhlIG5hdmlnYXRpb24gb3V0c2lkZSBvZiBOYXZpZ2F0b3JTY3JlZW4uXG5cdFx0aWYgKFxuXHRcdFx0aXNJbml0aWFsTG9jYXRpb24gfHxcblx0XHRcdCEgaXNNYXRjaCB8fFxuXHRcdFx0ISB3cmFwcGVyUmVmLmN1cnJlbnQgfHxcblx0XHRcdGxvY2F0aW9uUmVmLmN1cnJlbnQuaGFzUmVzdG9yZWRGb2N1cyB8fFxuXHRcdFx0bG9jYXRpb24uc2tpcEZvY3VzXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWN0aXZlRWxlbWVudCA9IHdyYXBwZXJSZWYuY3VycmVudC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cblx0XHQvLyBJZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCB3aXRoaW4gdGhlIHdyYXBwZXIgZG8gbm90IGZvY3VzIHRoZVxuXHRcdC8vIGVsZW1lbnQuIFRoaXMgcHJldmVudHMgaW5wdXRzIG9yIGJ1dHRvbnMgZnJvbSBsb3NpbmcgZm9jdXMgdW5uZWNlc3NhcmlseS5cblx0XHRpZiAoIHdyYXBwZXJSZWYuY3VycmVudC5jb250YWlucyggYWN0aXZlRWxlbWVudCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBlbGVtZW50VG9Gb2N1czogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuXHRcdC8vIFdoZW4gbmF2aWdhdGluZyBiYWNrLCBpZiBhIHNlbGVjdG9yIGlzIHByb3ZpZGVkLCB1c2UgaXQgdG8gbG9vayBmb3IgdGhlXG5cdFx0Ly8gdGFyZ2V0IGVsZW1lbnQgKGFzc3VtZWQgdG8gYmUgYSBub2RlIGluc2lkZSB0aGUgY3VycmVudCBOYXZpZ2F0b3JTY3JlZW4pXG5cdFx0aWYgKCBsb2NhdGlvbi5pc0JhY2sgJiYgbG9jYXRpb24/LmZvY3VzVGFyZ2V0U2VsZWN0b3IgKSB7XG5cdFx0XHRlbGVtZW50VG9Gb2N1cyA9IHdyYXBwZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKFxuXHRcdFx0XHRsb2NhdGlvbi5mb2N1c1RhcmdldFNlbGVjdG9yXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBwcmV2aW91cyBxdWVyeSBkaWRuJ3QgcnVuIG9yIGZpbmQgYW55IGVsZW1lbnQgdG8gZm9jdXMsIGZhbGxiYWNrXG5cdFx0Ly8gdG8gdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgaW4gdGhlIHNjcmVlbiAob3IgdGhlIHNjcmVlbiBpdHNlbGYpLlxuXHRcdGlmICggISBlbGVtZW50VG9Gb2N1cyApIHtcblx0XHRcdGNvbnN0IGZpcnN0VGFiYmFibGUgPSAoXG5cdFx0XHRcdGZvY3VzLnRhYmJhYmxlLmZpbmQoIHdyYXBwZXJSZWYuY3VycmVudCApIGFzIEhUTUxFbGVtZW50W11cblx0XHRcdCApWyAwIF07XG5cdFx0XHRlbGVtZW50VG9Gb2N1cyA9IGZpcnN0VGFiYmFibGUgPz8gd3JhcHBlclJlZi5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGxvY2F0aW9uUmVmLmN1cnJlbnQuaGFzUmVzdG9yZWRGb2N1cyA9IHRydWU7XG5cdFx0ZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcblx0fSwgW1xuXHRcdGlzSW5pdGlhbExvY2F0aW9uLFxuXHRcdGlzTWF0Y2gsXG5cdFx0bG9jYXRpb24uaXNCYWNrLFxuXHRcdGxvY2F0aW9uLmZvY3VzVGFyZ2V0U2VsZWN0b3IsXG5cdFx0bG9jYXRpb24uc2tpcEZvY3VzLFxuXHRdICk7XG5cblx0Y29uc3QgbWVyZ2VkV3JhcHBlclJlZiA9IHVzZU1lcmdlUmVmcyggWyBmb3J3YXJkZWRSZWYsIHdyYXBwZXJSZWYgXSApO1xuXG5cdGlmICggISBpc01hdGNoICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKCBwcmVmZXJzUmVkdWNlZE1vdGlvbiApIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFZpZXdcblx0XHRcdFx0cmVmPXsgbWVyZ2VkV3JhcHBlclJlZiB9XG5cdFx0XHRcdGNsYXNzTmFtZT17IGNsYXNzZXMgfVxuXHRcdFx0XHR7IC4uLm90aGVyUHJvcHMgfVxuXHRcdFx0PlxuXHRcdFx0XHR7IGNoaWxkcmVuIH1cblx0XHRcdDwvVmlldz5cblx0XHQpO1xuXHR9XG5cblx0Y29uc3QgYW5pbWF0ZSA9IHtcblx0XHRvcGFjaXR5OiAxLFxuXHRcdHRyYW5zaXRpb246IHtcblx0XHRcdGRlbGF5OiBhbmltYXRpb25FbnRlckRlbGF5LFxuXHRcdFx0ZHVyYXRpb246IGFuaW1hdGlvbkVudGVyRHVyYXRpb24sXG5cdFx0XHRlYXNlOiAnZWFzZUluT3V0Jyxcblx0XHR9LFxuXHRcdHg6IDAsXG5cdH07XG5cdC8vIERpc2FibGUgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGlmIHRoZSBzY3JlZW4gaXMgdGhlIHZlcnkgZmlyc3Qgc2NyZWVuIHRvIGJlXG5cdC8vIHJlbmRlcmVkIHdpdGhpbiB0aGUgY3VycmVudCBgTmF2aWdhdG9yUHJvdmlkZXJgLlxuXHRjb25zdCBpbml0aWFsID1cblx0XHRsb2NhdGlvbi5pc0luaXRpYWwgJiYgISBsb2NhdGlvbi5pc0JhY2tcblx0XHRcdD8gZmFsc2Vcblx0XHRcdDoge1xuXHRcdFx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRcdFx0eDpcblx0XHRcdFx0XHRcdCggaXNSVEwoKSAmJiBsb2NhdGlvbi5pc0JhY2sgKSB8fFxuXHRcdFx0XHRcdFx0KCAhIGlzUlRMKCkgJiYgISBsb2NhdGlvbi5pc0JhY2sgKVxuXHRcdFx0XHRcdFx0XHQ/IDUwXG5cdFx0XHRcdFx0XHRcdDogLTUwLFxuXHRcdFx0ICB9O1xuXHRjb25zdCBleGl0ID0ge1xuXHRcdGRlbGF5OiBhbmltYXRpb25FeGl0RGVsYXksXG5cdFx0b3BhY2l0eTogMCxcblx0XHR4OlxuXHRcdFx0KCAhIGlzUlRMKCkgJiYgbG9jYXRpb24uaXNCYWNrICkgfHwgKCBpc1JUTCgpICYmICEgbG9jYXRpb24uaXNCYWNrIClcblx0XHRcdFx0PyA1MFxuXHRcdFx0XHQ6IC01MCxcblx0XHR0cmFuc2l0aW9uOiB7XG5cdFx0XHRkdXJhdGlvbjogYW5pbWF0aW9uRXhpdER1cmF0aW9uLFxuXHRcdFx0ZWFzZTogJ2Vhc2VJbk91dCcsXG5cdFx0fSxcblx0fTtcblxuXHRjb25zdCBhbmltYXRlZFByb3BzID0ge1xuXHRcdGFuaW1hdGUsXG5cdFx0ZXhpdCxcblx0XHRpbml0aWFsLFxuXHR9O1xuXG5cdHJldHVybiAoXG5cdFx0PG1vdGlvbi5kaXZcblx0XHRcdHJlZj17IG1lcmdlZFdyYXBwZXJSZWYgfVxuXHRcdFx0Y2xhc3NOYW1lPXsgY2xhc3NlcyB9XG5cdFx0XHR7IC4uLm90aGVyUHJvcHMgfVxuXHRcdFx0eyAuLi5hbmltYXRlZFByb3BzIH1cblx0XHQ+XG5cdFx0XHR7IGNoaWxkcmVuIH1cblx0XHQ8L21vdGlvbi5kaXY+XG5cdCk7XG59XG5cbi8qKlxuICogVGhlIGBOYXZpZ2F0b3JTY3JlZW5gIGNvbXBvbmVudCByZXByZXNlbnRzIGEgc2luZ2xlIHZpZXcvc2NyZWVuL3BhbmVsIGFuZFxuICogc2hvdWxkIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgYE5hdmlnYXRvclByb3ZpZGVyYCwgdGhlXG4gKiBgTmF2aWdhdG9yQnV0dG9uYCBhbmQgdGhlIGBOYXZpZ2F0b3JCYWNrQnV0dG9uYCBjb21wb25lbnRzIChvciB0aGUgYHVzZU5hdmlnYXRvcmBcbiAqIGhvb2spLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7XG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yUHJvdmlkZXIgYXMgTmF2aWdhdG9yUHJvdmlkZXIsXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yU2NyZWVuIGFzIE5hdmlnYXRvclNjcmVlbixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JCdXR0b24gYXMgTmF2aWdhdG9yQnV0dG9uLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvckJhY2tCdXR0b24gYXMgTmF2aWdhdG9yQmFja0J1dHRvbixcbiAqIH0gZnJvbSAnQHdvcmRwcmVzcy9jb21wb25lbnRzJztcbiAqXG4gKiBjb25zdCBNeU5hdmlnYXRpb24gPSAoKSA9PiAoXG4gKiAgIDxOYXZpZ2F0b3JQcm92aWRlciBpbml0aWFsUGF0aD1cIi9cIj5cbiAqICAgICA8TmF2aWdhdG9yU2NyZWVuIHBhdGg9XCIvXCI+XG4gKiAgICAgICA8cD5UaGlzIGlzIHRoZSBob21lIHNjcmVlbi48L3A+XG4gKiAgICAgICAgPE5hdmlnYXRvckJ1dHRvbiBwYXRoPVwiL2NoaWxkXCI+XG4gKiAgICAgICAgICBOYXZpZ2F0ZSB0byBjaGlsZCBzY3JlZW4uXG4gKiAgICAgICA8L05hdmlnYXRvckJ1dHRvbj5cbiAqICAgICA8L05hdmlnYXRvclNjcmVlbj5cbiAqXG4gKiAgICAgPE5hdmlnYXRvclNjcmVlbiBwYXRoPVwiL2NoaWxkXCI+XG4gKiAgICAgICA8cD5UaGlzIGlzIHRoZSBjaGlsZCBzY3JlZW4uPC9wPlxuICogICAgICAgPE5hdmlnYXRvckJhY2tCdXR0b24+XG4gKiAgICAgICAgIEdvIGJhY2tcbiAqICAgICAgIDwvTmF2aWdhdG9yQmFja0J1dHRvbj5cbiAqICAgICA8L05hdmlnYXRvclNjcmVlbj5cbiAqICAgPC9OYXZpZ2F0b3JQcm92aWRlcj5cbiAqICk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IE5hdmlnYXRvclNjcmVlbiA9IGNvbnRleHRDb25uZWN0KFxuXHRVbmNvbm5lY3RlZE5hdmlnYXRvclNjcmVlbixcblx0J05hdmlnYXRvclNjcmVlbidcbik7XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRvclNjcmVlbjtcbiJdfQ== */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
function UnconnectedNavigatorScreen(props, forwardedRef) {
  const screenId = useId();
  const {
    children,
    className,
    path,
    ...otherProps
  } = useContextSystem(props, 'NavigatorScreen');
  const prefersReducedMotion = useReducedMotion();
  const {
    location,
    match,
    addScreen,
    removeScreen
  } = useContext(NavigatorContext);
  const isMatch = match === screenId;
  const wrapperRef = useRef(null);
  useEffect(() => {
    const screen = {
      id: screenId,
      path: escapeAttribute(path)
    };
    addScreen(screen);
    return () => removeScreen(screen);
  }, [screenId, path, addScreen, removeScreen]);
  const cx = useCx();
  const classes = useMemo(() => cx(_ref, className), [className, cx]);
  const locationRef = useRef(location);
  useEffect(() => {
    locationRef.current = location;
  }, [location]);

  // Focus restoration
  const isInitialLocation = location.isInitial && !location.isBack;
  useEffect(() => {
    // Only attempt to restore focus:
    // - if the current location is not the initial one (to avoid moving focus on page load)
    // - when the screen becomes visible
    // - if the wrapper ref has been assigned
    // - if focus hasn't already been restored for the current location
    // - if the `skipFocus` option is not set to `true`. This is useful when we trigger the navigation outside of NavigatorScreen.
    if (isInitialLocation || !isMatch || !wrapperRef.current || locationRef.current.hasRestoredFocus || location.skipFocus) {
      return;
    }
    const activeElement = wrapperRef.current.ownerDocument.activeElement;

    // If an element is already focused within the wrapper do not focus the
    // element. This prevents inputs or buttons from losing focus unnecessarily.
    if (wrapperRef.current.contains(activeElement)) {
      return;
    }
    let elementToFocus = null;

    // When navigating back, if a selector is provided, use it to look for the
    // target element (assumed to be a node inside the current NavigatorScreen)
    if (location.isBack && location?.focusTargetSelector) {
      elementToFocus = wrapperRef.current.querySelector(location.focusTargetSelector);
    }

    // If the previous query didn't run or find any element to focus, fallback
    // to the first tabbable element in the screen (or the screen itself).
    if (!elementToFocus) {
      const firstTabbable = focus.tabbable.find(wrapperRef.current)[0];
      elementToFocus = firstTabbable !== null && firstTabbable !== void 0 ? firstTabbable : wrapperRef.current;
    }
    locationRef.current.hasRestoredFocus = true;
    elementToFocus.focus();
  }, [isInitialLocation, isMatch, location.isBack, location.focusTargetSelector, location.skipFocus]);
  const mergedWrapperRef = useMergeRefs([forwardedRef, wrapperRef]);
  if (!isMatch) {
    return null;
  }
  if (prefersReducedMotion) {
    return createElement(View, {
      ref: mergedWrapperRef,
      className: classes,
      ...otherProps
    }, children);
  }
  const animate = {
    opacity: 1,
    transition: {
      delay: animationEnterDelay,
      duration: animationEnterDuration,
      ease: 'easeInOut'
    },
    x: 0
  };
  // Disable the initial animation if the screen is the very first screen to be
  // rendered within the current `NavigatorProvider`.
  const initial = location.isInitial && !location.isBack ? false : {
    opacity: 0,
    x: isRTL() && location.isBack || !isRTL() && !location.isBack ? 50 : -50
  };
  const exit = {
    delay: animationExitDelay,
    opacity: 0,
    x: !isRTL() && location.isBack || isRTL() && !location.isBack ? 50 : -50,
    transition: {
      duration: animationExitDuration,
      ease: 'easeInOut'
    }
  };
  const animatedProps = {
    animate,
    exit,
    initial
  };
  return createElement(motion.div, {
    ref: mergedWrapperRef,
    className: classes,
    ...otherProps,
    ...animatedProps
  }, children);
}

/**
 * The `NavigatorScreen` component represents a single view/screen/panel and
 * should be used in combination with the `NavigatorProvider`, the
 * `NavigatorButton` and the `NavigatorBackButton` components (or the `useNavigator`
 * hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
export const NavigatorScreen = contextConnect(UnconnectedNavigatorScreen, 'NavigatorScreen');
export default NavigatorScreen;
//# sourceMappingURL=component.js.map