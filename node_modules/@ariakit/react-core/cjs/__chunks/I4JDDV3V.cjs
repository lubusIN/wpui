"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _LHHW5ZQPcjs = require('./LHHW5ZQP.cjs');




var _CWY2PHPRcjs = require('./CWY2PHPR.cjs');




var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/focusable/focusable.ts
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');






var _events = require('@ariakit/core/utils/events');




var _focus = require('@ariakit/core/utils/focus');
var _platform = require('@ariakit/core/utils/platform');
var isSafariBrowser = _platform.isSafari.call(void 0, );
var alwaysFocusVisibleInputTypes = [
  "text",
  "search",
  "url",
  "tel",
  "email",
  "password",
  "number",
  "date",
  "month",
  "week",
  "time",
  "datetime",
  "datetime-local"
];
function isAlwaysFocusVisible(element) {
  const { tagName, readOnly, type } = element;
  if (tagName === "TEXTAREA" && !readOnly)
    return true;
  if (tagName === "SELECT" && !readOnly)
    return true;
  if (tagName === "INPUT" && !readOnly) {
    return alwaysFocusVisibleInputTypes.includes(type);
  }
  if (element.isContentEditable)
    return true;
  return false;
}
function isAlwaysFocusVisibleDelayed(element) {
  const role = element.getAttribute("role");
  if (role !== "combobox")
    return false;
  return !!element.dataset.name;
}
function getLabels(element) {
  if ("labels" in element) {
    return element.labels;
  }
  return null;
}
function isNativeCheckboxOrRadio(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "input" && element.type) {
    return element.type === "radio" || element.type === "checkbox";
  }
  return false;
}
function isNativeTabbable(tagName) {
  if (!tagName)
    return true;
  return tagName === "button" || tagName === "input" || tagName === "select" || tagName === "textarea" || tagName === "a";
}
function supportsDisabledAttribute(tagName) {
  if (!tagName)
    return true;
  return tagName === "button" || tagName === "input" || tagName === "select" || tagName === "textarea";
}
function getTabIndex(focusable, trulyDisabled, nativeTabbable, supportsDisabled, tabIndexProp) {
  if (!focusable) {
    return tabIndexProp;
  }
  if (trulyDisabled) {
    if (nativeTabbable && !supportsDisabled) {
      return -1;
    }
    return;
  }
  if (nativeTabbable) {
    return tabIndexProp;
  }
  return tabIndexProp || 0;
}
function useDisableEvent(onEvent, disabled) {
  return _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
    onEvent == null ? void 0 : onEvent(event);
    if (event.defaultPrevented)
      return;
    if (disabled) {
      event.stopPropagation();
      event.preventDefault();
    }
  });
}
var isKeyboardModality = true;
function onGlobalMouseDown(event) {
  const target = event.target;
  if (target && "hasAttribute" in target) {
    if (!target.hasAttribute("data-focus-visible")) {
      isKeyboardModality = false;
    }
  }
}
function onGlobalKeyDown(event) {
  if (event.metaKey)
    return;
  if (event.ctrlKey)
    return;
  if (event.altKey)
    return;
  isKeyboardModality = true;
}
var useFocusable = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      focusable = true,
      accessibleWhenDisabled,
      autoFocus,
      onFocusVisible
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "focusable",
      "accessibleWhenDisabled",
      "autoFocus",
      "onFocusVisible"
    ]);
    const ref = _react.useRef.call(void 0, null);
    _react.useEffect.call(void 0, () => {
      if (!focusable)
        return;
      _events.addGlobalEventListener.call(void 0, "mousedown", onGlobalMouseDown, true);
      _events.addGlobalEventListener.call(void 0, "keydown", onGlobalKeyDown, true);
    }, [focusable]);
    if (isSafariBrowser) {
      _react.useEffect.call(void 0, () => {
        if (!focusable)
          return;
        const element = ref.current;
        if (!element)
          return;
        if (!isNativeCheckboxOrRadio(element))
          return;
        const labels = getLabels(element);
        if (!labels)
          return;
        const onMouseUp = () => queueMicrotask(() => element.focus());
        labels.forEach((label) => label.addEventListener("mouseup", onMouseUp));
        return () => {
          labels.forEach(
            (label) => label.removeEventListener("mouseup", onMouseUp)
          );
        };
      }, [focusable]);
    }
    const disabled = focusable && props.disabled;
    const trulyDisabled = !!disabled && !accessibleWhenDisabled;
    const [focusVisible, setFocusVisible] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!focusable)
        return;
      if (trulyDisabled && focusVisible) {
        setFocusVisible(false);
      }
    }, [focusable, trulyDisabled, focusVisible]);
    _react.useEffect.call(void 0, () => {
      if (!focusable)
        return;
      if (!focusVisible)
        return;
      const element = ref.current;
      if (!element)
        return;
      if (typeof IntersectionObserver === "undefined")
        return;
      const observer = new IntersectionObserver(() => {
        if (!_focus.isFocusable.call(void 0, element)) {
          setFocusVisible(false);
        }
      });
      observer.observe(element);
      return () => observer.disconnect();
    }, [focusable, focusVisible]);
    const onKeyPressCapture = useDisableEvent(
      props.onKeyPressCapture,
      disabled
    );
    const onMouseDownCapture = useDisableEvent(
      props.onMouseDownCapture,
      disabled
    );
    const onClickCapture = useDisableEvent(props.onClickCapture, disabled);
    const onMouseDownProp = props.onMouseDown;
    const onMouseDown = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (!focusable)
        return;
      const element = event.currentTarget;
      if (!isSafariBrowser)
        return;
      if (_events.isPortalEvent.call(void 0, event))
        return;
      if (!_dom.isButton.call(void 0, element) && !isNativeCheckboxOrRadio(element))
        return;
      let receivedFocus = false;
      const onFocus = () => {
        receivedFocus = true;
      };
      const options = { capture: true, once: true };
      element.addEventListener("focusin", onFocus, options);
      _events.queueBeforeEvent.call(void 0, element, "mouseup", () => {
        element.removeEventListener("focusin", onFocus, true);
        if (receivedFocus)
          return;
        _focus.focusIfNeeded.call(void 0, element);
      });
    });
    const handleFocusVisible = (event, currentTarget) => {
      if (currentTarget) {
        event.currentTarget = currentTarget;
      }
      onFocusVisible == null ? void 0 : onFocusVisible(event);
      if (event.defaultPrevented)
        return;
      if (!focusable)
        return;
      const element = event.currentTarget;
      if (!element)
        return;
      if (!_focus.hasFocus.call(void 0, element))
        return;
      setFocusVisible(true);
    };
    const onKeyDownCaptureProp = props.onKeyDownCapture;
    const onKeyDownCapture = _5WLTMVVQcjs.useEvent.call(void 0, 
      (event) => {
        onKeyDownCaptureProp == null ? void 0 : onKeyDownCaptureProp(event);
        if (event.defaultPrevented)
          return;
        if (!focusable)
          return;
        if (focusVisible)
          return;
        if (event.metaKey)
          return;
        if (event.altKey)
          return;
        if (event.ctrlKey)
          return;
        if (!_events.isSelfTarget.call(void 0, event))
          return;
        const element = event.currentTarget;
        queueMicrotask(() => handleFocusVisible(event, element));
      }
    );
    const onFocusCaptureProp = props.onFocusCapture;
    const onFocusCapture = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onFocusCaptureProp == null ? void 0 : onFocusCaptureProp(event);
      if (event.defaultPrevented)
        return;
      if (!focusable)
        return;
      if (!_events.isSelfTarget.call(void 0, event)) {
        setFocusVisible(false);
        return;
      }
      const element = event.currentTarget;
      const applyFocusVisible = () => handleFocusVisible(event, element);
      if (isKeyboardModality || isAlwaysFocusVisible(event.target)) {
        queueMicrotask(applyFocusVisible);
      } else if (isAlwaysFocusVisibleDelayed(event.target)) {
        _events.queueBeforeEvent.call(void 0, event.target, "focusout", applyFocusVisible);
      } else {
        setFocusVisible(false);
      }
    });
    const onBlurProp = props.onBlur;
    const onBlur = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (!focusable)
        return;
      if (!_events.isFocusEventOutside.call(void 0, event))
        return;
      setFocusVisible(false);
    });
    const autoFocusOnShow = _react.useContext.call(void 0, _LHHW5ZQPcjs.FocusableContext);
    const autoFocusRef = _5WLTMVVQcjs.useEvent.call(void 0, (element) => {
      if (!focusable)
        return;
      if (!autoFocus)
        return;
      if (!element)
        return;
      if (!autoFocusOnShow)
        return;
      queueMicrotask(() => {
        if (_focus.hasFocus.call(void 0, element))
          return;
        if (!_focus.isFocusable.call(void 0, element))
          return;
        element.focus();
      });
    });
    const tagName = _5WLTMVVQcjs.useTagName.call(void 0, ref, props.as);
    const nativeTabbable = focusable && isNativeTabbable(tagName);
    const supportsDisabled = focusable && supportsDisabledAttribute(tagName);
    const style = trulyDisabled ? _72I2GWXFcjs.__spreadValues.call(void 0, { pointerEvents: "none" }, props.style) : props.style;
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      "data-focus-visible": focusable && focusVisible ? "" : void 0,
      "data-autofocus": autoFocus ? true : void 0,
      "aria-disabled": disabled ? true : void 0
    }, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, autoFocusRef, props.ref),
      style,
      tabIndex: getTabIndex(
        focusable,
        trulyDisabled,
        nativeTabbable,
        supportsDisabled,
        props.tabIndex
      ),
      disabled: supportsDisabled && trulyDisabled ? true : void 0,
      // TODO: Test Focusable contentEditable.
      contentEditable: disabled ? void 0 : props.contentEditable,
      onKeyPressCapture,
      onClickCapture,
      onMouseDownCapture,
      onMouseDown,
      onKeyDownCapture,
      onFocusCapture,
      onBlur
    });
    return props;
  }
);
var Focusable = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  props = useFocusable(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "div", props);
});
if (process.env.NODE_ENV !== "production") {
  Focusable.displayName = "Focusable";
}




exports.useFocusable = useFocusable; exports.Focusable = Focusable;
