"use strict";Object.defineProperty(exports, "__esModule", {value: true});





var _KLZID3QOcjs = require('./KLZID3QO.cjs');


var _5VOPA6D3cjs = require('./5VOPA6D3.cjs');


var _I4JDDV3Vcjs = require('./I4JDDV3V.cjs');




var _CWY2PHPRcjs = require('./CWY2PHPR.cjs');






var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/composite/composite.tsx
var _react = require('react');
var _array = require('@ariakit/core/utils/array');
var _dom = require('@ariakit/core/utils/dom');





var _events = require('@ariakit/core/utils/events');
var _focus = require('@ariakit/core/utils/focus');
var _jsxruntime = require('react/jsx-runtime');
function isGrid(items) {
  return items.some((item) => !!item.rowId);
}
function isPrintableKey(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function isModifierKey(event) {
  return event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta";
}
function canProxyKeyboardEvent(event, state) {
  if (!_events.isSelfTarget.call(void 0, event))
    return false;
  if (isModifierKey(event))
    return false;
  const target = event.target;
  if (!target)
    return true;
  if (_dom.isTextField.call(void 0, target)) {
    if (isPrintableKey(event))
      return false;
    const grid = isGrid(state.renderedItems);
    const focusingInputOnly = state.activeId === null;
    const allowHorizontalNavigationOnItems = grid && !focusingInputOnly;
    const isHomeOrEnd = event.key === "Home" || event.key === "End";
    if (!allowHorizontalNavigationOnItems && isHomeOrEnd)
      return false;
  }
  return !event.isPropagationStopped();
}
function useKeyboardEventProxy(store, onKeyboardEvent, previousElementRef) {
  return _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
    var _a;
    onKeyboardEvent == null ? void 0 : onKeyboardEvent(event);
    if (event.defaultPrevented)
      return;
    const state = store.getState();
    const activeElement = (_a = _KLZID3QOcjs.getEnabledItem.call(void 0, store, state.activeId)) == null ? void 0 : _a.element;
    if (!activeElement)
      return;
    if (!canProxyKeyboardEvent(event, state))
      return;
    const _b = event, { view } = _b, eventInit = _72I2GWXFcjs.__objRest.call(void 0, _b, ["view"]);
    const previousElement = previousElementRef == null ? void 0 : previousElementRef.current;
    if (activeElement !== previousElement) {
      activeElement.focus();
    }
    if (!_events.fireKeyboardEvent.call(void 0, activeElement, event.type, eventInit)) {
      event.preventDefault();
    }
    if (event.currentTarget.contains(activeElement)) {
      event.stopPropagation();
    }
  });
}
function findFirstEnabledItemInTheLastRow(items) {
  return _KLZID3QOcjs.findFirstEnabledItem.call(void 0, 
    _array.flatten2DArray.call(void 0, _array.reverseArray.call(void 0, _KLZID3QOcjs.groupItemsByRows.call(void 0, items)))
  );
}
function useScheduleFocus(store) {
  const [scheduled, setScheduled] = _react.useState.call(void 0, false);
  const schedule = _react.useCallback.call(void 0, () => setScheduled(true), []);
  const activeItem = store.useState(
    (state) => _KLZID3QOcjs.getEnabledItem.call(void 0, store, state.activeId)
  );
  _react.useEffect.call(void 0, () => {
    const activeElement = activeItem == null ? void 0 : activeItem.element;
    if (!scheduled)
      return;
    if (!activeElement)
      return;
    setScheduled(false);
    activeElement.focus({ preventScroll: true });
  }, [activeItem, scheduled]);
  return schedule;
}
var useComposite = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      composite = true,
      focusOnMove = composite,
      moveOnKeyPress = true
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "store",
      "composite",
      "focusOnMove",
      "moveOnKeyPress"
    ]);
    const previousElementRef = _react.useRef.call(void 0, null);
    const scheduleFocus = useScheduleFocus(store);
    const moves = store.useState("moves");
    _react.useEffect.call(void 0, () => {
      var _a2;
      if (!moves)
        return;
      if (!composite)
        return;
      if (!focusOnMove)
        return;
      const { activeId: activeId2 } = store.getState();
      const itemElement = (_a2 = _KLZID3QOcjs.getEnabledItem.call(void 0, store, activeId2)) == null ? void 0 : _a2.element;
      if (!itemElement)
        return;
      _focus.focusIntoView.call(void 0, itemElement);
    }, [moves, composite, focusOnMove]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!composite)
        return;
      if (!moves)
        return;
      const { baseElement, activeId: activeId2 } = store.getState();
      const isSelfAcive = activeId2 === null;
      if (!isSelfAcive)
        return;
      if (!baseElement)
        return;
      const previousElement = previousElementRef.current;
      previousElementRef.current = null;
      if (previousElement) {
        _events.fireBlurEvent.call(void 0, previousElement, { relatedTarget: baseElement });
      }
      if (_focus.hasFocus.call(void 0, baseElement)) {
        _events.fireFocusEvent.call(void 0, baseElement, { relatedTarget: previousElement });
      } else {
        baseElement.focus();
      }
    }, [moves, composite]);
    const activeId = store.useState("activeId");
    const virtualFocus = store.useState("virtualFocus");
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      var _a2;
      if (!composite)
        return;
      if (!virtualFocus)
        return;
      const previousElement = previousElementRef.current;
      previousElementRef.current = null;
      if (!previousElement)
        return;
      const activeElement = (_a2 = _KLZID3QOcjs.getEnabledItem.call(void 0, store, activeId)) == null ? void 0 : _a2.element;
      const relatedTarget = activeElement || _dom.getActiveElement.call(void 0, previousElement);
      _events.fireBlurEvent.call(void 0, previousElement, { relatedTarget });
    }, [activeId, virtualFocus, composite]);
    const onKeyDownCapture = useKeyboardEventProxy(
      store,
      props.onKeyDownCapture,
      previousElementRef
    );
    const onKeyUpCapture = useKeyboardEventProxy(
      store,
      props.onKeyUpCapture,
      previousElementRef
    );
    const onFocusCaptureProp = props.onFocusCapture;
    const onFocusCapture = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onFocusCaptureProp == null ? void 0 : onFocusCaptureProp(event);
      if (event.defaultPrevented)
        return;
      const { virtualFocus: virtualFocus2 } = store.getState();
      if (!virtualFocus2)
        return;
      const previousActiveElement = event.relatedTarget;
      const isSilentlyFocused = _KLZID3QOcjs.silentlyFocused.call(void 0, event.currentTarget);
      if (_events.isSelfTarget.call(void 0, event) && isSilentlyFocused) {
        event.stopPropagation();
        previousElementRef.current = previousActiveElement;
      }
    });
    const onFocusProp = props.onFocus;
    const onFocus = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (event.defaultPrevented)
        return;
      if (!composite)
        return;
      const { relatedTarget } = event;
      const { virtualFocus: virtualFocus2 } = store.getState();
      if (virtualFocus2) {
        if (_events.isSelfTarget.call(void 0, event) && !_KLZID3QOcjs.isItem.call(void 0, store, relatedTarget)) {
          queueMicrotask(scheduleFocus);
        }
      } else if (_events.isSelfTarget.call(void 0, event)) {
        store.setActiveId(null);
      }
    });
    const onBlurCaptureProp = props.onBlurCapture;
    const onBlurCapture = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      var _a2;
      onBlurCaptureProp == null ? void 0 : onBlurCaptureProp(event);
      if (event.defaultPrevented)
        return;
      const { virtualFocus: virtualFocus2, activeId: activeId2 } = store.getState();
      if (!virtualFocus2)
        return;
      const activeElement = (_a2 = _KLZID3QOcjs.getEnabledItem.call(void 0, store, activeId2)) == null ? void 0 : _a2.element;
      const nextActiveElement = event.relatedTarget;
      const nextActiveElementIsItem = _KLZID3QOcjs.isItem.call(void 0, store, nextActiveElement);
      const previousElement = previousElementRef.current;
      previousElementRef.current = null;
      if (_events.isSelfTarget.call(void 0, event) && nextActiveElementIsItem) {
        if (nextActiveElement === activeElement) {
          if (previousElement && previousElement !== nextActiveElement) {
            _events.fireBlurEvent.call(void 0, previousElement, event);
          }
        } else if (activeElement) {
          _events.fireBlurEvent.call(void 0, activeElement, event);
        }
        event.stopPropagation();
      } else {
        const targetIsItem = _KLZID3QOcjs.isItem.call(void 0, store, event.target);
        if (!targetIsItem && activeElement) {
          _events.fireBlurEvent.call(void 0, activeElement, event);
        }
      }
    });
    const onKeyDownProp = props.onKeyDown;
    const moveOnKeyPressProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, moveOnKeyPress);
    const onKeyDown = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      var _a2;
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (!_events.isSelfTarget.call(void 0, event))
        return;
      const { orientation, items, renderedItems, activeId: activeId2 } = store.getState();
      const activeItem = _KLZID3QOcjs.getEnabledItem.call(void 0, store, activeId2);
      if ((_a2 = activeItem == null ? void 0 : activeItem.element) == null ? void 0 : _a2.isConnected)
        return;
      const isVertical = orientation !== "horizontal";
      const isHorizontal = orientation !== "vertical";
      const grid = isGrid(renderedItems);
      const up = () => {
        if (grid) {
          const item = items && findFirstEnabledItemInTheLastRow(items);
          return item == null ? void 0 : item.id;
        }
        return store.last();
      };
      const keyMap = {
        ArrowUp: (grid || isVertical) && up,
        ArrowRight: (grid || isHorizontal) && store.first,
        ArrowDown: (grid || isVertical) && store.first,
        ArrowLeft: (grid || isHorizontal) && store.last,
        Home: store.first,
        End: store.last,
        PageUp: store.first,
        PageDown: store.last
      };
      const action = keyMap[event.key];
      if (action) {
        const id = action();
        if (id !== void 0) {
          if (!moveOnKeyPressProp(event))
            return;
          event.preventDefault();
          store.move(id);
        }
      }
    });
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _5VOPA6D3cjs.CompositeContext.Provider, { value: store, children: element }),
      [store]
    );
    const activeDescendant = store.useState(
      (state) => {
        var _a2;
        return composite && state.virtualFocus ? (_a2 = _KLZID3QOcjs.getEnabledItem.call(void 0, store, state.activeId)) == null ? void 0 : _a2.id : void 0;
      }
    );
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      "aria-activedescendant": activeDescendant
    }, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, composite ? store.setBaseElement : null, props.ref),
      onKeyDownCapture,
      onKeyUpCapture,
      onFocusCapture,
      onFocus,
      onBlurCapture,
      onKeyDown
    });
    const focusable = store.useState(
      (state) => composite && (state.virtualFocus || state.activeId === null)
    );
    props = _I4JDDV3Vcjs.useFocusable.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { focusable }, props));
    return props;
  }
);
var Composite = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useComposite(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Composite.displayName = "Composite";
}




exports.useComposite = useComposite; exports.Composite = Composite;
