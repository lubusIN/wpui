import {
  useMergeRefs
} from "./J7Q2EO23.js";
import {
  getRefProperty,
  mergeProps
} from "./CP3U4HPL.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/utils/system.tsx
import * as React from "react";
import { hasOwnProperty } from "@ariakit/core/utils/misc";
import { jsx } from "react/jsx-runtime";
function isRenderProp(children) {
  return typeof children === "function";
}
function forwardRef2(render) {
  const Role = React.forwardRef((props, ref) => render(__spreadProps(__spreadValues({}, props), { ref })));
  Role.displayName = render.displayName || render.name;
  return Role;
}
function memo2(Component, propsAreEqual) {
  const Role = React.memo(Component, propsAreEqual);
  Role.displayName = Component.displayName || Component.name;
  return Role;
}
function createComponent(render) {
  const Role = (props, ref) => render(__spreadValues({ ref }, props));
  return React.forwardRef(Role);
}
function createMemoComponent(render) {
  const Role = createComponent(render);
  return React.memo(Role);
}
function createElement(Type, props) {
  const _a = props, { as: As, wrapElement, render } = _a, rest = __objRest(_a, ["as", "wrapElement", "render"]);
  let element;
  const mergedRef = useMergeRefs(props.ref, getRefProperty(render));
  if (As && typeof As !== "string") {
    element = /* @__PURE__ */ jsx(As, __spreadProps(__spreadValues({}, rest), { render }));
  } else if (React.isValidElement(render)) {
    const renderProps = __spreadProps(__spreadValues({}, render.props), { ref: mergedRef });
    element = React.cloneElement(render, mergeProps(rest, renderProps));
  } else if (render) {
    element = render(rest);
  } else if (isRenderProp(props.children)) {
    const _b = rest, { children } = _b, otherProps = __objRest(_b, ["children"]);
    element = props.children(otherProps);
  } else if (As) {
    element = /* @__PURE__ */ jsx(As, __spreadValues({}, rest));
  } else {
    element = /* @__PURE__ */ jsx(Type, __spreadValues({}, rest));
  }
  if (wrapElement) {
    return wrapElement(element);
  }
  return element;
}
function createHook(useProps) {
  const useRole = (props = {}) => {
    const htmlProps = useProps(props);
    const copy = {};
    for (const prop in htmlProps) {
      if (hasOwnProperty(htmlProps, prop) && htmlProps[prop] !== void 0) {
        copy[prop] = htmlProps[prop];
      }
    }
    return copy;
  };
  return useRole;
}

export {
  forwardRef2 as forwardRef,
  memo2 as memo,
  createComponent,
  createMemoComponent,
  createElement,
  createHook
};
