import {
  DialogBackdrop
} from "./5IZLNERH.js";
import {
  disableTreeOutside
} from "./NHPU54IO.js";
import {
  disableAccessibilityTreeOutside
} from "./GDORSOK6.js";
import {
  usePreventBodyScroll
} from "./3LAWLNOX.js";
import {
  useNestedDialogs
} from "./PLOINBVB.js";
import {
  useHideOnInteractOutside
} from "./E5XSMSHD.js";
import {
  isElementMarked,
  markTreeOutside
} from "./LEBYH5FW.js";
import {
  prependHiddenDismiss
} from "./62DFK33R.js";
import {
  useFocusableContainer
} from "./IYNN2ZO5.js";
import {
  HeadingLevel
} from "./6OMX4H3W.js";
import {
  usePortal
} from "./LL3AE4N4.js";
import {
  DialogContext,
  DialogDescriptionContext,
  DialogHeadingContext
} from "./LNHZLQEK.js";
import {
  isHidden,
  useDisclosureContent
} from "./WHEEIXMF.js";
import {
  useFocusable
} from "./MYID4V27.js";
import {
  createComponent,
  createElement,
  createHook
} from "./NQJBHION.js";
import {
  useBooleanEvent,
  useEvent,
  useId,
  useMergeRefs,
  usePortalRef,
  useSafeLayoutEffect,
  useWrapElement
} from "./J7Q2EO23.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/dialog/dialog.tsx
import { useCallback, useEffect, useRef, useState } from "react";
import {
  closest,
  contains,
  getActiveElement,
  getDocument,
  isButton
} from "@ariakit/core/utils/dom";
import {
  addGlobalEventListener,
  queueBeforeEvent
} from "@ariakit/core/utils/events";
import {
  focusIfNeeded,
  getFirstTabbableIn,
  isFocusable
} from "@ariakit/core/utils/focus";
import { chain } from "@ariakit/core/utils/misc";
import { isSafari } from "@ariakit/core/utils/platform";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var isSafariBrowser = isSafari();
function isAlreadyFocusingAnotherElement(dialog) {
  const activeElement = getActiveElement();
  if (!activeElement)
    return false;
  if (dialog && contains(dialog, activeElement))
    return false;
  if (isFocusable(activeElement))
    return true;
  return false;
}
function getElementFromProp(prop, focusable = false) {
  if (!prop)
    return null;
  const element = "current" in prop ? prop.current : prop;
  if (!element)
    return null;
  if (focusable)
    return isFocusable(element) ? element : null;
  return element;
}
var useDialog = createHook(
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      modal = true,
      portal = !!modal,
      backdrop = !!modal,
      backdropProps,
      hideOnEscape = true,
      hideOnInteractOutside = true,
      getPersistentElements,
      preventBodyScroll = !!modal,
      autoFocusOnShow = true,
      autoFocusOnHide = true,
      initialFocus,
      finalFocus
    } = _b, props = __objRest(_b, [
      "store",
      "focusable",
      "modal",
      "portal",
      "backdrop",
      "backdropProps",
      "hideOnEscape",
      "hideOnInteractOutside",
      "getPersistentElements",
      "preventBodyScroll",
      "autoFocusOnShow",
      "autoFocusOnHide",
      "initialFocus",
      "finalFocus"
    ]);
    const ref = useRef(null);
    const { portalRef, domReady } = usePortalRef(portal, props.portalRef);
    const preserveTabOrderProp = props.preserveTabOrder;
    const preserveTabOrder = store.useState(
      (state) => preserveTabOrderProp && !modal && state.mounted
    );
    const id = useId(props.id);
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const contentElement = store.useState("contentElement");
    const hidden = isHidden(mounted, props.hidden, props.alwaysVisible);
    usePreventBodyScroll(contentElement, id, preventBodyScroll && !hidden);
    useHideOnInteractOutside(store, hideOnInteractOutside, domReady);
    const { wrapElement, nestedDialogs } = useNestedDialogs(store);
    props = useWrapElement(props, wrapElement, [wrapElement]);
    useSafeLayoutEffect(() => {
      if (!open)
        return;
      const dialog = ref.current;
      const activeElement = getActiveElement(dialog, true);
      if (!activeElement)
        return;
      if (activeElement.tagName === "BODY")
        return;
      if (dialog && contains(dialog, activeElement))
        return;
      store.setDisclosureElement(activeElement);
    }, [open, store]);
    if (isSafariBrowser) {
      useEffect(() => {
        if (!mounted)
          return;
        const { disclosureElement } = store.getState();
        if (!disclosureElement)
          return;
        if (!isButton(disclosureElement))
          return;
        const onMouseDown = () => {
          let receivedFocus = false;
          const onFocus = () => {
            receivedFocus = true;
          };
          const options = { capture: true, once: true };
          disclosureElement.addEventListener("focusin", onFocus, options);
          queueBeforeEvent(disclosureElement, "mouseup", () => {
            disclosureElement.removeEventListener("focusin", onFocus, true);
            if (receivedFocus)
              return;
            focusIfNeeded(disclosureElement);
          });
        };
        disclosureElement.addEventListener("mousedown", onMouseDown);
        return () => {
          disclosureElement.removeEventListener("mousedown", onMouseDown);
        };
      }, [mounted, store]);
    }
    const shouldDisableAccessibilityTree = modal || // Usually, we only want to disable the accessibility tree outside if the
    // dialog is a modal. But the Portal component can't preserve the tab
    // order on Safari/VoiceOver. By allowing only the dialog/portal to be
    // accessible, we provide a similar tab order flow. We don't need to
    // disable pointer events because it's just for screen readers.
    portal && preserveTabOrder && isSafari();
    useEffect(() => {
      if (!mounted)
        return;
      if (!domReady)
        return;
      const dialog = ref.current;
      if (!dialog)
        return;
      if (!shouldDisableAccessibilityTree)
        return;
      const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
      if (existingDismiss)
        return;
      return prependHiddenDismiss(dialog, store.hide);
    }, [mounted, domReady, shouldDisableAccessibilityTree]);
    const getPersistentElementsProp = useEvent(getPersistentElements);
    useSafeLayoutEffect(() => {
      if (!domReady)
        return;
      if (!id)
        return;
      if (!open)
        return;
      const { disclosureElement } = store.getState();
      const dialog = ref.current;
      const persistentElements = getPersistentElementsProp() || [];
      const allElements = [
        dialog,
        ...persistentElements,
        ...nestedDialogs.map((dialog2) => dialog2.getState().contentElement)
      ];
      if (!shouldDisableAccessibilityTree) {
        return markTreeOutside(id, disclosureElement, ...allElements);
      }
      if (modal) {
        return chain(
          markTreeOutside(id, ...allElements),
          disableTreeOutside(...allElements)
        );
      }
      return chain(
        markTreeOutside(id, disclosureElement, ...allElements),
        disableAccessibilityTreeOutside(...allElements)
      );
    }, [
      domReady,
      id,
      open,
      store,
      getPersistentElementsProp,
      nestedDialogs,
      shouldDisableAccessibilityTree,
      modal
    ]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const autoFocusOnShowProp = useBooleanEvent(autoFocusOnShow);
    const [autoFocusEnabled, setAutoFocusEnabled] = useState(false);
    useEffect(() => {
      if (!open)
        return;
      if (!mayAutoFocusOnShow)
        return;
      if (!domReady)
        return;
      if (!(contentElement == null ? void 0 : contentElement.isConnected))
        return;
      const element = getElementFromProp(initialFocus, true) || // If no initial focus is specified, we try to focus the first element
      // with the autofocus attribute. If it's an Ariakit component, the
      // Focusable component will consume the autoFocus prop and add the
      // data-autofocus attribute to the element instead.
      contentElement.querySelector(
        "[data-autofocus=true],[autofocus]"
      ) || // We have to fallback to the first focusable element otherwise portaled
      // dialogs with preserveTabOrder set to true will not receive focus
      // properly because the elements aren't tabbable until the dialog
      // receives focus.
      getFirstTabbableIn(contentElement, true, portal && preserveTabOrder) || // Finally, we fallback to the dialog element itself.
      contentElement;
      const isElementFocusable = isFocusable(element);
      if (!autoFocusOnShowProp(isElementFocusable ? element : null))
        return;
      setAutoFocusEnabled(true);
      queueMicrotask(() => {
        element.focus();
        if (!isSafariBrowser)
          return;
        element.scrollIntoView({ block: "nearest", inline: "nearest" });
      });
    }, [
      open,
      mayAutoFocusOnShow,
      domReady,
      contentElement,
      initialFocus,
      portal,
      preserveTabOrder,
      autoFocusOnShowProp
    ]);
    const mayAutoFocusOnHide = !!autoFocusOnHide;
    const autoFocusOnHideProp = useBooleanEvent(autoFocusOnHide);
    const [hasOpened, setHasOpened] = useState(false);
    useEffect(() => {
      if (!open)
        return;
      setHasOpened(true);
      return () => setHasOpened(false);
    }, [open]);
    const focusOnHide = useCallback(
      (dialog, retry = true) => {
        const { open: open2, disclosureElement } = store.getState();
        if (open2)
          return;
        if (isAlreadyFocusingAnotherElement(dialog))
          return;
        let element = getElementFromProp(finalFocus) || disclosureElement;
        if (element == null ? void 0 : element.id) {
          const doc = getDocument(element);
          const selector = `[aria-activedescendant="${element.id}"]`;
          const composite = doc.querySelector(selector);
          if (composite) {
            element = composite;
          }
        }
        if (element && !isFocusable(element)) {
          const maybeParentDialog = closest(element, "[data-dialog]");
          if (maybeParentDialog && maybeParentDialog.id) {
            const doc = getDocument(maybeParentDialog);
            const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
            const control = doc.querySelector(selector);
            if (control) {
              element = control;
            }
          }
        }
        const isElementFocusable = element && isFocusable(element);
        if (!isElementFocusable && retry) {
          requestAnimationFrame(() => focusOnHide(dialog, false));
          return;
        }
        if (!autoFocusOnHideProp(isElementFocusable ? element : null))
          return;
        if (!isElementFocusable)
          return;
        element == null ? void 0 : element.focus();
      },
      [store, finalFocus, autoFocusOnHideProp]
    );
    useEffect(() => {
      if (open)
        return;
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      focusOnHide(dialog);
    }, [open, hasOpened, mayAutoFocusOnHide, focusOnHide]);
    useEffect(() => {
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      return () => focusOnHide(dialog);
    }, [hasOpened, mayAutoFocusOnHide, focusOnHide]);
    const hideOnEscapeProp = useBooleanEvent(hideOnEscape);
    useEffect(() => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      const onKeyDown = (event) => {
        if (event.key !== "Escape")
          return;
        if (event.defaultPrevented)
          return;
        const dialog = ref.current;
        if (!dialog)
          return;
        if (isElementMarked(dialog))
          return;
        const target = event.target;
        if (!target)
          return;
        const { disclosureElement } = store.getState();
        const isValidTarget = () => {
          if (target.tagName === "BODY")
            return true;
          if (contains(dialog, target))
            return true;
          if (!disclosureElement)
            return false;
          if (contains(disclosureElement, target))
            return true;
          return false;
        };
        if (!isValidTarget())
          return;
        if (!hideOnEscapeProp(event))
          return;
        store.hide();
      };
      return addGlobalEventListener("keydown", onKeyDown);
    }, [mounted, domReady, store, hideOnEscapeProp]);
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(HeadingLevel, { level: modal ? 1 : void 0, children: element }),
      [modal]
    );
    const hiddenProp = props.hidden;
    const alwaysVisible = props.alwaysVisible;
    props = useWrapElement(
      props,
      (element) => {
        if (!backdrop)
          return element;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(
            DialogBackdrop,
            {
              store,
              backdrop,
              backdropProps,
              hidden: hiddenProp,
              alwaysVisible
            }
          ),
          element
        ] });
      },
      [store, backdrop, backdropProps, hiddenProp, alwaysVisible]
    );
    const [headingId, setHeadingId] = useState();
    const [descriptionId, setDescriptionId] = useState();
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(DialogContext.Provider, { value: store, children: /* @__PURE__ */ jsx(DialogHeadingContext.Provider, { value: setHeadingId, children: /* @__PURE__ */ jsx(DialogDescriptionContext.Provider, { value: setDescriptionId, children: element }) }) }),
      [store]
    );
    props = __spreadProps(__spreadValues({
      id,
      "data-dialog": "",
      role: "dialog",
      tabIndex: focusable ? -1 : void 0,
      "aria-labelledby": headingId,
      "aria-describedby": descriptionId
    }, props), {
      ref: useMergeRefs(ref, props.ref)
    });
    props = useFocusableContainer(__spreadProps(__spreadValues({}, props), {
      autoFocusOnShow: autoFocusEnabled
    }));
    props = useDisclosureContent(__spreadValues({ store }, props));
    props = useFocusable(__spreadProps(__spreadValues({}, props), { focusable }));
    props = usePortal(__spreadProps(__spreadValues({ portal }, props), { portalRef, preserveTabOrder }));
    return props;
  }
);
var Dialog = createComponent((props) => {
  const htmlProps = useDialog(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Dialog.displayName = "Dialog";
}

export {
  useDialog,
  Dialog
};
