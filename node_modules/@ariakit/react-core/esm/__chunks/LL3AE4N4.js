import {
  FocusTrap
} from "./EJ3GIT5B.js";
import {
  PortalContext
} from "./LDDPB3PY.js";
import {
  createComponent,
  createElement,
  createHook
} from "./NQJBHION.js";
import {
  useMergeRefs,
  useSafeLayoutEffect,
  useWrapElement
} from "./J7Q2EO23.js";
import {
  setRef
} from "./CP3U4HPL.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/portal/portal.tsx
import { useContext, useEffect, useRef, useState } from "react";
import { getDocument } from "@ariakit/core/utils/dom";
import { isFocusEventOutside } from "@ariakit/core/utils/events";
import {
  disableFocusIn,
  getNextTabbable,
  getPreviousTabbable,
  restoreFocusIn
} from "@ariakit/core/utils/focus";
import { createPortal } from "react-dom";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
function getRootElement(element) {
  return getDocument(element).body;
}
function getPortalElement(element, portalElement) {
  if (!portalElement) {
    return getDocument(element).createElement("div");
  }
  if (typeof portalElement === "function") {
    return portalElement(element);
  }
  return portalElement;
}
function getRandomId(prefix = "id") {
  return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).substr(2, 6)}`;
}
function queueFocus(element) {
  queueMicrotask(() => {
    element == null ? void 0 : element.focus();
  });
}
var usePortal = createHook(
  (_a) => {
    var _b = _a, { preserveTabOrder, portalElement, portalRef, portal = true } = _b, props = __objRest(_b, ["preserveTabOrder", "portalElement", "portalRef", "portal"]);
    const ref = useRef(null);
    const refProp = useMergeRefs(ref, props.ref);
    const context = useContext(PortalContext);
    const [portalNode, setPortalNode] = useState(null);
    const outerBeforeRef = useRef(null);
    const innerBeforeRef = useRef(null);
    const innerAfterRef = useRef(null);
    const outerAfterRef = useRef(null);
    useSafeLayoutEffect(() => {
      const element = ref.current;
      if (!element || !portal) {
        setPortalNode(null);
        return;
      }
      const portalEl = getPortalElement(element, portalElement);
      if (!portalEl) {
        setPortalNode(null);
        return;
      }
      const isPortalInDocument = portalEl.isConnected;
      if (!isPortalInDocument) {
        const rootElement = context || getRootElement(element);
        rootElement.appendChild(portalEl);
      }
      if (!portalEl.id) {
        portalEl.id = element.id ? `portal/${element.id}` : getRandomId();
      }
      setPortalNode(portalEl);
      setRef(portalRef, portalEl);
      if (isPortalInDocument)
        return;
      return () => {
        portalEl.remove();
        setRef(portalRef, null);
      };
    }, [portal, portalElement, context, portalRef]);
    useEffect(() => {
      if (!portalNode)
        return;
      if (!preserveTabOrder)
        return;
      let raf = 0;
      const onFocus = (event) => {
        if (!isFocusEventOutside(event))
          return;
        const focusing = event.type === "focusin";
        if (focusing)
          return restoreFocusIn(portalNode);
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          disableFocusIn(portalNode, true);
        });
      };
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder]);
    props = useWrapElement(
      props,
      (element) => {
        element = // While the portal node is not in the DOM, we need to pass the
        // current context to the portal context, otherwise it's going to
        // reset to the body element on nested portals.
        /* @__PURE__ */ jsx(PortalContext.Provider, { value: portalNode || context, children: element });
        if (!portal)
          return element;
        if (!portalNode) {
          return /* @__PURE__ */ jsx(
            "span",
            {
              ref: refProp,
              id: props.id,
              style: { position: "fixed" },
              hidden: true
            }
          );
        }
        element = /* @__PURE__ */ jsxs(Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: innerBeforeRef,
              className: "__focus-trap-inner-before",
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(getNextTabbable());
                } else {
                  queueFocus(outerBeforeRef.current);
                }
              }
            }
          ),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: innerAfterRef,
              className: "__focus-trap-inner-after",
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(getPreviousTabbable());
                } else {
                  queueFocus(outerAfterRef.current);
                }
              }
            }
          )
        ] });
        if (portalNode) {
          element = createPortal(element, portalNode);
        }
        element = /* @__PURE__ */ jsxs(Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: outerBeforeRef,
              className: "__focus-trap-outer-before",
              onFocus: (event) => {
                const fromOuter = event.relatedTarget === outerAfterRef.current;
                if (!fromOuter && isFocusEventOutside(event, portalNode)) {
                  queueFocus(innerBeforeRef.current);
                } else {
                  queueFocus(getPreviousTabbable());
                }
              }
            }
          ),
          preserveTabOrder && // We're using position: fixed here so that the browser doesn't
          // add margin to the element when setting gap on a parent element.
          /* @__PURE__ */ jsx("span", { "aria-owns": portalNode == null ? void 0 : portalNode.id, style: { position: "fixed" } }),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: outerAfterRef,
              className: "__focus-trap-outer-after",
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(innerAfterRef.current);
                } else {
                  const nextTabbable = getNextTabbable();
                  if (nextTabbable === innerBeforeRef.current) {
                    requestAnimationFrame(() => {
                      var _a2;
                      return (_a2 = getNextTabbable()) == null ? void 0 : _a2.focus();
                    });
                    return;
                  }
                  queueFocus(nextTabbable);
                }
              }
            }
          )
        ] });
        return element;
      },
      [portalNode, context, portal, props.id, preserveTabOrder]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: refProp
    });
    return props;
  }
);
var Portal = createComponent((props) => {
  const htmlProps = usePortal(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}

export {
  usePortal,
  Portal
};
