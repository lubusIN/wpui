import {
  usePopoverAnchor
} from "../__chunks/7PHM3O7I.js";
import {
  useComposite
} from "../__chunks/AAVDGJD5.js";
import "../__chunks/OXPV2NBK.js";
import "../__chunks/WJ37OVG2.js";
import "../__chunks/MYID4V27.js";
import "../__chunks/BMLNRUFQ.js";
import {
  createComponent,
  createElement,
  createHook
} from "../__chunks/NQJBHION.js";
import {
  useBooleanEvent,
  useEvent,
  useForceUpdate,
  useId,
  useMergeRefs,
  useSafeLayoutEffect,
  useUpdateEffect,
  useUpdateLayoutEffect
} from "../__chunks/J7Q2EO23.js";
import "../__chunks/CP3U4HPL.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "../__chunks/PNRLI7OV.js";

// src/combobox/combobox.ts
import { useEffect, useMemo, useRef, useState } from "react";
import { getPopupRole, getScrollingElement } from "@ariakit/core/utils/dom";
import {
  isFocusEventOutside,
  queueBeforeEvent
} from "@ariakit/core/utils/events";
import { hasFocus } from "@ariakit/core/utils/focus";
import {
  isFalsyBooleanCallback,
  normalizeString
} from "@ariakit/core/utils/misc";
function isFirstItemAutoSelected(items, activeValue, autoSelect) {
  if (!autoSelect)
    return false;
  const firstItem = items.find((item) => !item.disabled && item.value);
  return (firstItem == null ? void 0 : firstItem.value) === activeValue;
}
function hasCompletionString(value, activeValue) {
  if (!activeValue)
    return false;
  if (value == null)
    return false;
  value = normalizeString(value);
  return activeValue.length > value.length && activeValue.toLowerCase().indexOf(value.toLowerCase()) === 0;
}
function isInputEvent(event) {
  return event.type === "input";
}
function isAriaAutoCompleteValue(value) {
  return value === "inline" || value === "list" || value === "both" || value === "none";
}
var useCombobox = createHook(
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      autoSelect: autoSelectProp = false,
      showOnChange = true,
      setValueOnChange = true,
      showOnMouseDown = true,
      setValueOnClick = true,
      showOnKeyDown = true,
      moveOnKeyPress = true,
      autoComplete = "list"
    } = _b, props = __objRest(_b, [
      "store",
      "focusable",
      "autoSelect",
      "showOnChange",
      "setValueOnChange",
      "showOnMouseDown",
      "setValueOnClick",
      "showOnKeyDown",
      "moveOnKeyPress",
      "autoComplete"
    ]);
    const ref = useRef(null);
    const [valueUpdated, forceValueUpdate] = useForceUpdate();
    const canAutoSelectRef = useRef(false);
    const composingRef = useRef(false);
    const autoSelect = store.useState(
      (state) => !!autoSelectProp && state.virtualFocus
    );
    const inline = autoComplete === "inline" || autoComplete === "both";
    const [canInline, setCanInline] = useState(inline);
    useUpdateLayoutEffect(() => {
      if (!inline)
        return;
      setCanInline(true);
    }, [inline]);
    const storeValue = store.useState("value");
    const activeValue = store.useState(
      (state) => inline && canInline ? state.activeValue : void 0
    );
    const items = store.useState("renderedItems");
    const open = store.useState("open");
    const contentElement = store.useState("contentElement");
    const value = useMemo(() => {
      if (!inline)
        return storeValue;
      if (!canInline)
        return storeValue;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (firstItemAutoSelected) {
        if (hasCompletionString(storeValue, activeValue)) {
          const slice = (activeValue == null ? void 0 : activeValue.slice(storeValue.length)) || "";
          return storeValue + slice;
        }
        return storeValue;
      }
      return activeValue || storeValue;
    }, [inline, canInline, items, activeValue, autoSelect, storeValue]);
    useEffect(() => {
      const element = ref.current;
      if (!element)
        return;
      const onCompositeItemMove = () => setCanInline(true);
      element.addEventListener("combobox-item-move", onCompositeItemMove);
      return () => {
        element.removeEventListener("combobox-item-move", onCompositeItemMove);
      };
    }, []);
    useEffect(() => {
      if (!inline)
        return;
      if (!canInline)
        return;
      if (!activeValue)
        return;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (!firstItemAutoSelected)
        return;
      if (!hasCompletionString(storeValue, activeValue))
        return;
      queueMicrotask(() => {
        const element = ref.current;
        if (!element)
          return;
        element.setSelectionRange(storeValue.length, activeValue.length);
      });
    }, [
      valueUpdated,
      inline,
      canInline,
      activeValue,
      items,
      autoSelect,
      storeValue
    ]);
    const scrollingElementRef = useRef(null);
    useEffect(() => {
      if (!open)
        return;
      if (!contentElement)
        return;
      const scrollingElement = getScrollingElement(contentElement);
      if (!scrollingElement)
        return;
      scrollingElementRef.current = scrollingElement;
      const onWheel = () => {
        canAutoSelectRef.current = false;
      };
      const onScroll = () => {
        const { activeId } = store.getState();
        if (activeId === null)
          return;
        if (activeId === store.first())
          return;
        canAutoSelectRef.current = false;
      };
      const options = { passive: true, capture: true };
      scrollingElement.addEventListener("wheel", onWheel, options);
      scrollingElement.addEventListener("scroll", onScroll, options);
      return () => {
        scrollingElement.removeEventListener("wheel", onWheel, true);
        scrollingElement.removeEventListener("scroll", onScroll, true);
      };
    }, [open, contentElement, store]);
    useSafeLayoutEffect(() => {
      if (!storeValue)
        return;
      if (composingRef.current)
        return;
      canAutoSelectRef.current = true;
    }, [storeValue]);
    useSafeLayoutEffect(() => {
      if (open)
        return;
      canAutoSelectRef.current = false;
    }, [open]);
    useUpdateEffect(() => {
      var _a2;
      if (!autoSelect)
        return;
      if (!canAutoSelectRef.current)
        return;
      const { baseElement, contentElement: contentElement2 } = store.getState();
      if (baseElement && !hasFocus(baseElement))
        return;
      if (contentElement2 == null ? void 0 : contentElement2.hasAttribute("data-placing")) {
        const observer = new MutationObserver(forceValueUpdate);
        observer.observe(contentElement2, { attributeFilter: ["data-placing"] });
        return () => observer.disconnect();
      }
      store.move((_a2 = store.first()) != null ? _a2 : null);
      return;
    }, [store, valueUpdated, storeValue, autoSelect, items]);
    useSafeLayoutEffect(() => {
      if (autoSelect)
        return;
      store.setActiveId(null);
    }, [valueUpdated, autoSelect, store]);
    useEffect(() => {
      if (!inline)
        return;
      const combobox = ref.current;
      if (!combobox)
        return;
      const elements = [combobox, contentElement].filter(
        (value2) => !!value2
      );
      const onBlur2 = (event) => {
        if (elements.every((el) => isFocusEventOutside(event, el))) {
          store.setValue(value);
        }
      };
      elements.forEach((el) => el.addEventListener("focusout", onBlur2));
      return () => {
        elements.forEach((el) => el.removeEventListener("focusout", onBlur2));
      };
    }, [inline, contentElement, store, value]);
    const onChangeProp = props.onChange;
    const showOnChangeProp = useBooleanEvent(showOnChange);
    const setValueOnChangeProp = useBooleanEvent(setValueOnChange);
    const onChange = useEvent((event) => {
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented)
        return;
      const { value: value2, selectionStart } = event.target;
      const nativeEvent = event.nativeEvent;
      canAutoSelectRef.current = true;
      if (isInputEvent(nativeEvent)) {
        if (nativeEvent.isComposing) {
          canAutoSelectRef.current = false;
          composingRef.current = true;
        }
        if (inline) {
          const textInserted = nativeEvent.inputType === "insertText" || nativeEvent.inputType === "insertCompositionText";
          const caretAtEnd = selectionStart === value2.length;
          setCanInline(textInserted && caretAtEnd);
        }
      }
      if (setValueOnChangeProp(event)) {
        const isSameValue = value2 === store.getState().value;
        store.setValue(value2);
        if (inline && autoSelect && isSameValue) {
          forceValueUpdate();
        }
      }
      if (showOnChangeProp(event)) {
        store.show();
      }
      if (!autoSelect || !canAutoSelectRef.current) {
        store.setActiveId(null);
      }
    });
    const onCompositionEndProp = props.onCompositionEnd;
    const onCompositionEnd = useEvent(
      (event) => {
        canAutoSelectRef.current = true;
        composingRef.current = false;
        onCompositionEndProp == null ? void 0 : onCompositionEndProp(event);
        if (event.defaultPrevented)
          return;
        if (!autoSelect)
          return;
        forceValueUpdate();
      }
    );
    const onMouseDownProp = props.onMouseDown;
    const setValueOnClickProp = useBooleanEvent(setValueOnClick);
    const showOnMouseDownProp = useBooleanEvent(showOnMouseDown);
    const onMouseDown = useEvent((event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.button)
        return;
      if (event.ctrlKey)
        return;
      store.setActiveId(null);
      if (setValueOnClickProp(event)) {
        store.setValue(value);
      }
      if (showOnMouseDownProp(event)) {
        queueBeforeEvent(event.currentTarget, "mouseup", store.show);
      }
    });
    const onKeyDownProp = props.onKeyDown;
    const showOnKeyDownProp = useBooleanEvent(showOnKeyDown);
    const onKeyDown = useEvent(
      (event) => {
        onKeyDownProp == null ? void 0 : onKeyDownProp(event);
        if (event.defaultPrevented)
          return;
        if (event.ctrlKey)
          return;
        if (event.altKey)
          return;
        if (event.shiftKey)
          return;
        if (event.metaKey)
          return;
        const { open: open2, activeId } = store.getState();
        if (open2)
          return;
        if (activeId !== null)
          return;
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
          if (showOnKeyDownProp(event)) {
            event.preventDefault();
            store.show();
          }
        }
      }
    );
    const onBlurProp = props.onBlur;
    const onBlur = useEvent((event) => {
      canAutoSelectRef.current = false;
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (event.defaultPrevented)
        return;
    });
    const id = useId(props.id);
    const ariaAutoComplete = isAriaAutoCompleteValue(autoComplete) ? autoComplete : void 0;
    props = __spreadProps(__spreadValues({
      id,
      role: "combobox",
      "aria-autocomplete": ariaAutoComplete,
      "aria-haspopup": getPopupRole(contentElement, "listbox"),
      "aria-expanded": open,
      "aria-controls": contentElement == null ? void 0 : contentElement.id,
      value
    }, props), {
      ref: useMergeRefs(ref, props.ref),
      onChange,
      onCompositionEnd,
      onMouseDown,
      onKeyDown,
      onBlur
    });
    props = useComposite(__spreadProps(__spreadValues({
      store,
      focusable
    }, props), {
      // Enable inline autocomplete when the user moves from the combobox input
      // to an item.
      moveOnKeyPress: (event) => {
        if (isFalsyBooleanCallback(moveOnKeyPress, event))
          return false;
        if (inline)
          setCanInline(true);
        return true;
      }
    }));
    props = usePopoverAnchor(__spreadValues({ store }, props));
    return __spreadValues({ autoComplete: "off" }, props);
  }
);
var Combobox = createComponent((props) => {
  const htmlProps = useCombobox(props);
  return createElement("input", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Combobox.displayName = "Combobox";
}
export {
  Combobox,
  useCombobox
};
