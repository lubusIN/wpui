{"version":3,"names":["useState","useLayoutEffect","getFormatElement","range","editableContentElement","tagName","className","element","startContainer","nodeType","TEXT_NODE","startOffset","length","nextSibling","firstChild","ELEMENT_NODE","parentElement","contains","selector","matches","createVirtualAnchorElement","contextElement","getBoundingClientRect","getAnchor","ownerDocument","defaultView","selection","getSelection","rangeCount","getRangeAt","formatElement","useAnchor","settings","anchor","setAnchor","callback","attach","addEventListener","detach","removeEventListener","activeElement"],"sources":["@wordpress/rich-text/src/component/use-anchor.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// Even if the active format is defined, the actualy DOM range's start\n\t// container may be outside of the format's DOM element:\n\t// `a‸<strong>b</strong>` (DOM) while visually it's `a<strong>‸b</strong>`.\n\t// So at a given selection index, start with the deepest format DOM element.\n\tif (\n\t\telement.nodeType === element.TEXT_NODE &&\n\t\trange.startOffset === element.length &&\n\t\telement.nextSibling\n\t) {\n\t\telement = element.nextSibling;\n\n\t\twhile ( element.firstChild ) {\n\t\t\telement = element.firstChild;\n\t\t}\n\t}\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) return;\n\tif ( element === editableContentElement ) return;\n\tif ( ! editableContentElement.contains( element ) ) return;\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) return;\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) return;\n\tif ( ! selection.rangeCount ) return;\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) return;\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) return formatElement;\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) return;\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tif ( editableContentElement === ownerDocument.activeElement ) {\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn detach;\n\t}, [ editableContentElement, tagName, className ] );\n\n\treturn anchor;\n}\n"],"mappings":"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"}