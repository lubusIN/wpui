"use strict";Object.defineProperty(exports, "__esModule", {value: true});



var _FS2K2N7Ucjs = require('./FS2K2N7U.cjs');



var _RCYVACJOcjs = require('./RCYVACJO.cjs');


var _EXM2AW52cjs = require('./EXM2AW52.cjs');



var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/collection/collection-store.ts
function isElementPreceding(a, b) {
  return Boolean(
    b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING
  );
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.element;
    const elementB = b.element;
    if (elementA === elementB)
      return 0;
    if (!elementA || !elementB)
      return 0;
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function getCommonParent(items) {
  var _a;
  const firstItem = items.find((item) => !!item.element);
  const lastItem = [...items].reverse().find((item) => !!item.element);
  let parentElement = (_a = firstItem == null ? void 0 : firstItem.element) == null ? void 0 : _a.parentElement;
  while (parentElement && (lastItem == null ? void 0 : lastItem.element)) {
    const parent = parentElement;
    if (lastItem && parent.contains(lastItem.element)) {
      return parentElement;
    }
    parentElement = parentElement.parentElement;
  }
  return _EXM2AW52cjs.getDocument.call(void 0, parentElement).body;
}
function createCollectionStore(props = {}) {
  var _a;
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const items = _RCYVACJOcjs.defaultValue.call(void 0, 
    props.items,
    syncState == null ? void 0 : syncState.items,
    props.defaultItems,
    []
  );
  const itemsMap = new Map(items.map((item) => [item.id, item]));
  const initialState = {
    items,
    renderedItems: _RCYVACJOcjs.defaultValue.call(void 0, syncState == null ? void 0 : syncState.renderedItems, [])
  };
  const privateStore = _FS2K2N7Ucjs.createStore.call(void 0, {
    renderedItems: initialState.renderedItems
  });
  const collection = _FS2K2N7Ucjs.createStore.call(void 0, initialState, props.store);
  const sortItems = () => {
    const state = privateStore.getState();
    const renderedItems = sortBasedOnDOMPosition(state.renderedItems);
    privateStore.setState("renderedItems", renderedItems);
    collection.setState("renderedItems", renderedItems);
  };
  _FS2K2N7Ucjs.setup.call(void 0, collection, () => {
    return _FS2K2N7Ucjs.batch.call(void 0, privateStore, ["renderedItems"], (state) => {
      let firstRun = true;
      let raf = requestAnimationFrame(sortItems);
      if (typeof IntersectionObserver !== "function")
        return;
      const callback = () => {
        if (firstRun) {
          firstRun = false;
          return;
        }
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(sortItems);
      };
      const root = getCommonParent(state.renderedItems);
      const observer = new IntersectionObserver(callback, { root });
      state.renderedItems.forEach((item) => {
        if (!item.element)
          return;
        observer.observe(item.element);
      });
      return () => {
        cancelAnimationFrame(raf);
        observer.disconnect();
      };
    });
  });
  const mergeItem = (item, setItems, canDeleteFromMap = false) => {
    let prevItem;
    setItems((items2) => {
      const index = items2.findIndex(({ id }) => id === item.id);
      const nextItems = items2.slice();
      if (index !== -1) {
        prevItem = items2[index];
        const nextItem = _72I2GWXFcjs.__spreadValues.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, prevItem), item);
        nextItems[index] = nextItem;
        itemsMap.set(item.id, nextItem);
      } else {
        nextItems.push(item);
        itemsMap.set(item.id, item);
      }
      return nextItems;
    });
    const unmergeItem = () => {
      setItems((items2) => {
        if (!prevItem) {
          if (canDeleteFromMap) {
            itemsMap.delete(item.id);
          }
          return items2.filter(({ id }) => id !== item.id);
        }
        const index = items2.findIndex(({ id }) => id === item.id);
        if (index === -1)
          return items2;
        const nextItems = items2.slice();
        nextItems[index] = prevItem;
        itemsMap.set(item.id, prevItem);
        return nextItems;
      });
    };
    return unmergeItem;
  };
  const registerItem = (item) => mergeItem(item, (getItems) => collection.setState("items", getItems), true);
  return _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, collection), {
    registerItem,
    renderItem: (item) => _RCYVACJOcjs.chain.call(void 0, 
      registerItem(item),
      mergeItem(
        item,
        (getItems) => privateStore.setState("renderedItems", getItems)
      )
    ),
    item: (id) => {
      if (!id)
        return null;
      let item = itemsMap.get(id);
      if (!item) {
        const { items: items2 } = collection.getState();
        item = items2.find((item2) => item2.id === id);
        if (item) {
          itemsMap.set(id, item);
        }
      }
      return item || null;
    }
  });
}



exports.createCollectionStore = createCollectionStore;
