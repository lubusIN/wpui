"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _6MKUVCENcjs = require('../__chunks/6MKUVCEN.cjs');


var _A764D2YKcjs = require('../__chunks/A764D2YK.cjs');
require('../__chunks/KLZID3QO.cjs');
require('../__chunks/5VOPA6D3.cjs');
require('../__chunks/I4JDDV3V.cjs');
require('../__chunks/LHHW5ZQP.cjs');




var _CWY2PHPRcjs = require('../__chunks/CWY2PHPR.cjs');









var _5WLTMVVQcjs = require('../__chunks/5WLTMVVQ.cjs');
require('../__chunks/7WUTS26Y.cjs');




var _72I2GWXFcjs = require('../__chunks/72I2GWXF.cjs');

// src/combobox/combobox.ts
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');
var _focus = require('@ariakit/core/utils/focus');



var _misc = require('@ariakit/core/utils/misc');
function isFirstItemAutoSelected(items, activeValue, autoSelect) {
  if (!autoSelect)
    return false;
  const firstItem = items.find((item) => !item.disabled && item.value);
  return (firstItem == null ? void 0 : firstItem.value) === activeValue;
}
function hasCompletionString(value, activeValue) {
  if (!activeValue)
    return false;
  if (value == null)
    return false;
  value = _misc.normalizeString.call(void 0, value);
  return activeValue.length > value.length && activeValue.toLowerCase().indexOf(value.toLowerCase()) === 0;
}
function isInputEvent(event) {
  return event.type === "input";
}
function isAriaAutoCompleteValue(value) {
  return value === "inline" || value === "list" || value === "both" || value === "none";
}
var useCombobox = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      autoSelect: autoSelectProp = false,
      showOnChange = true,
      setValueOnChange = true,
      showOnMouseDown = true,
      setValueOnClick = true,
      showOnKeyDown = true,
      moveOnKeyPress = true,
      autoComplete = "list"
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "store",
      "focusable",
      "autoSelect",
      "showOnChange",
      "setValueOnChange",
      "showOnMouseDown",
      "setValueOnClick",
      "showOnKeyDown",
      "moveOnKeyPress",
      "autoComplete"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const [valueUpdated, forceValueUpdate] = _5WLTMVVQcjs.useForceUpdate.call(void 0, );
    const canAutoSelectRef = _react.useRef.call(void 0, false);
    const composingRef = _react.useRef.call(void 0, false);
    const autoSelect = store.useState(
      (state) => !!autoSelectProp && state.virtualFocus
    );
    const inline = autoComplete === "inline" || autoComplete === "both";
    const [canInline, setCanInline] = _react.useState.call(void 0, inline);
    _5WLTMVVQcjs.useUpdateLayoutEffect.call(void 0, () => {
      if (!inline)
        return;
      setCanInline(true);
    }, [inline]);
    const storeValue = store.useState("value");
    const activeValue = store.useState(
      (state) => inline && canInline ? state.activeValue : void 0
    );
    const items = store.useState("renderedItems");
    const open = store.useState("open");
    const contentElement = store.useState("contentElement");
    const value = _react.useMemo.call(void 0, () => {
      if (!inline)
        return storeValue;
      if (!canInline)
        return storeValue;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (firstItemAutoSelected) {
        if (hasCompletionString(storeValue, activeValue)) {
          const slice = (activeValue == null ? void 0 : activeValue.slice(storeValue.length)) || "";
          return storeValue + slice;
        }
        return storeValue;
      }
      return activeValue || storeValue;
    }, [inline, canInline, items, activeValue, autoSelect, storeValue]);
    _react.useEffect.call(void 0, () => {
      const element = ref.current;
      if (!element)
        return;
      const onCompositeItemMove = () => setCanInline(true);
      element.addEventListener("combobox-item-move", onCompositeItemMove);
      return () => {
        element.removeEventListener("combobox-item-move", onCompositeItemMove);
      };
    }, []);
    _react.useEffect.call(void 0, () => {
      if (!inline)
        return;
      if (!canInline)
        return;
      if (!activeValue)
        return;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (!firstItemAutoSelected)
        return;
      if (!hasCompletionString(storeValue, activeValue))
        return;
      queueMicrotask(() => {
        const element = ref.current;
        if (!element)
          return;
        element.setSelectionRange(storeValue.length, activeValue.length);
      });
    }, [
      valueUpdated,
      inline,
      canInline,
      activeValue,
      items,
      autoSelect,
      storeValue
    ]);
    const scrollingElementRef = _react.useRef.call(void 0, null);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      if (!contentElement)
        return;
      const scrollingElement = _dom.getScrollingElement.call(void 0, contentElement);
      if (!scrollingElement)
        return;
      scrollingElementRef.current = scrollingElement;
      const onWheel = () => {
        canAutoSelectRef.current = false;
      };
      const onScroll = () => {
        const { activeId } = store.getState();
        if (activeId === null)
          return;
        if (activeId === store.first())
          return;
        canAutoSelectRef.current = false;
      };
      const options = { passive: true, capture: true };
      scrollingElement.addEventListener("wheel", onWheel, options);
      scrollingElement.addEventListener("scroll", onScroll, options);
      return () => {
        scrollingElement.removeEventListener("wheel", onWheel, true);
        scrollingElement.removeEventListener("scroll", onScroll, true);
      };
    }, [open, contentElement, store]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!storeValue)
        return;
      if (composingRef.current)
        return;
      canAutoSelectRef.current = true;
    }, [storeValue]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (open)
        return;
      canAutoSelectRef.current = false;
    }, [open]);
    _5WLTMVVQcjs.useUpdateEffect.call(void 0, () => {
      var _a2;
      if (!autoSelect)
        return;
      if (!canAutoSelectRef.current)
        return;
      const { baseElement, contentElement: contentElement2 } = store.getState();
      if (baseElement && !_focus.hasFocus.call(void 0, baseElement))
        return;
      if (contentElement2 == null ? void 0 : contentElement2.hasAttribute("data-placing")) {
        const observer = new MutationObserver(forceValueUpdate);
        observer.observe(contentElement2, { attributeFilter: ["data-placing"] });
        return () => observer.disconnect();
      }
      store.move((_a2 = store.first()) != null ? _a2 : null);
      return;
    }, [store, valueUpdated, storeValue, autoSelect, items]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (autoSelect)
        return;
      store.setActiveId(null);
    }, [valueUpdated, autoSelect, store]);
    _react.useEffect.call(void 0, () => {
      if (!inline)
        return;
      const combobox = ref.current;
      if (!combobox)
        return;
      const elements = [combobox, contentElement].filter(
        (value2) => !!value2
      );
      const onBlur2 = (event) => {
        if (elements.every((el) => _events.isFocusEventOutside.call(void 0, event, el))) {
          store.setValue(value);
        }
      };
      elements.forEach((el) => el.addEventListener("focusout", onBlur2));
      return () => {
        elements.forEach((el) => el.removeEventListener("focusout", onBlur2));
      };
    }, [inline, contentElement, store, value]);
    const onChangeProp = props.onChange;
    const showOnChangeProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, showOnChange);
    const setValueOnChangeProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, setValueOnChange);
    const onChange = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented)
        return;
      const { value: value2, selectionStart } = event.target;
      const nativeEvent = event.nativeEvent;
      canAutoSelectRef.current = true;
      if (isInputEvent(nativeEvent)) {
        if (nativeEvent.isComposing) {
          canAutoSelectRef.current = false;
          composingRef.current = true;
        }
        if (inline) {
          const textInserted = nativeEvent.inputType === "insertText" || nativeEvent.inputType === "insertCompositionText";
          const caretAtEnd = selectionStart === value2.length;
          setCanInline(textInserted && caretAtEnd);
        }
      }
      if (setValueOnChangeProp(event)) {
        const isSameValue = value2 === store.getState().value;
        store.setValue(value2);
        if (inline && autoSelect && isSameValue) {
          forceValueUpdate();
        }
      }
      if (showOnChangeProp(event)) {
        store.show();
      }
      if (!autoSelect || !canAutoSelectRef.current) {
        store.setActiveId(null);
      }
    });
    const onCompositionEndProp = props.onCompositionEnd;
    const onCompositionEnd = _5WLTMVVQcjs.useEvent.call(void 0, 
      (event) => {
        canAutoSelectRef.current = true;
        composingRef.current = false;
        onCompositionEndProp == null ? void 0 : onCompositionEndProp(event);
        if (event.defaultPrevented)
          return;
        if (!autoSelect)
          return;
        forceValueUpdate();
      }
    );
    const onMouseDownProp = props.onMouseDown;
    const setValueOnClickProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, setValueOnClick);
    const showOnMouseDownProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, showOnMouseDown);
    const onMouseDown = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.button)
        return;
      if (event.ctrlKey)
        return;
      store.setActiveId(null);
      if (setValueOnClickProp(event)) {
        store.setValue(value);
      }
      if (showOnMouseDownProp(event)) {
        _events.queueBeforeEvent.call(void 0, event.currentTarget, "mouseup", store.show);
      }
    });
    const onKeyDownProp = props.onKeyDown;
    const showOnKeyDownProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, showOnKeyDown);
    const onKeyDown = _5WLTMVVQcjs.useEvent.call(void 0, 
      (event) => {
        onKeyDownProp == null ? void 0 : onKeyDownProp(event);
        if (event.defaultPrevented)
          return;
        if (event.ctrlKey)
          return;
        if (event.altKey)
          return;
        if (event.shiftKey)
          return;
        if (event.metaKey)
          return;
        const { open: open2, activeId } = store.getState();
        if (open2)
          return;
        if (activeId !== null)
          return;
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
          if (showOnKeyDownProp(event)) {
            event.preventDefault();
            store.show();
          }
        }
      }
    );
    const onBlurProp = props.onBlur;
    const onBlur = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      canAutoSelectRef.current = false;
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (event.defaultPrevented)
        return;
    });
    const id = _5WLTMVVQcjs.useId.call(void 0, props.id);
    const ariaAutoComplete = isAriaAutoCompleteValue(autoComplete) ? autoComplete : void 0;
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      id,
      role: "combobox",
      "aria-autocomplete": ariaAutoComplete,
      "aria-haspopup": _dom.getPopupRole.call(void 0, contentElement, "listbox"),
      "aria-expanded": open,
      "aria-controls": contentElement == null ? void 0 : contentElement.id,
      value
    }, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, props.ref),
      onChange,
      onCompositionEnd,
      onMouseDown,
      onKeyDown,
      onBlur
    });
    props = _A764D2YKcjs.useComposite.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      store,
      focusable
    }, props), {
      // Enable inline autocomplete when the user moves from the combobox input
      // to an item.
      moveOnKeyPress: (event) => {
        if (_misc.isFalsyBooleanCallback.call(void 0, moveOnKeyPress, event))
          return false;
        if (inline)
          setCanInline(true);
        return true;
      }
    }));
    props = _6MKUVCENcjs.usePopoverAnchor.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { store }, props));
    return _72I2GWXFcjs.__spreadValues.call(void 0, { autoComplete: "off" }, props);
  }
);
var Combobox = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useCombobox(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "input", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Combobox.displayName = "Combobox";
}



exports.Combobox = Combobox; exports.useCombobox = useCombobox;
