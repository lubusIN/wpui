"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = __experimentalRichText;
exports.useRichText = useRichText;
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _create = require("../create");
var _toDom = require("../to-dom");
var _toHtmlString = require("../to-html-string");
var _useDefaultStyle = require("./use-default-style");
var _useBoundaryStyle = require("./use-boundary-style");
var _useCopyHandler = require("./use-copy-handler");
var _useFormatBoundaries = require("./use-format-boundaries");
var _useSelectObject = require("./use-select-object");
var _useInputAndSelection = require("./use-input-and-selection");
var _useSelectionChangeCompat = require("./use-selection-change-compat");
var _useDelete = require("./use-delete");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useRichText({
  value = '',
  selectionStart,
  selectionEnd,
  placeholder,
  preserveWhiteSpace,
  onSelectionChange,
  onChange,
  __unstableDisableFormats: disableFormats,
  __unstableIsSelected: isSelected,
  __unstableDependencies = [],
  __unstableAfterParse,
  __unstableBeforeSerialize,
  __unstableAddInvisibleFormats
}) {
  const registry = (0, _data.useRegistry)();
  const [, forceRender] = (0, _element.useReducer)(() => ({}));
  const ref = (0, _element.useRef)();
  function createRecord() {
    const {
      ownerDocument: {
        defaultView
      }
    } = ref.current;
    const selection = defaultView.getSelection();
    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
    return (0, _create.create)({
      element: ref.current,
      range,
      __unstableIsEditableTree: true,
      preserveWhiteSpace
    });
  }
  function applyRecord(newRecord, {
    domOnly
  } = {}) {
    (0, _toDom.apply)({
      value: newRecord,
      current: ref.current,
      prepareEditableTree: __unstableAddInvisibleFormats,
      __unstableDomOnly: domOnly,
      placeholder
    });
  }

  // Internal values are updated synchronously, unlike props and state.
  const _value = (0, _element.useRef)(value);
  const record = (0, _element.useRef)();
  function setRecordFromProps() {
    _value.current = value;
    record.current = (0, _create.create)({
      html: value,
      preserveWhiteSpace
    });
    if (disableFormats) {
      record.current.formats = Array(value.length);
      record.current.replacements = Array(value.length);
    }
    if (__unstableAfterParse) {
      record.current.formats = __unstableAfterParse(record.current);
    }
    record.current.start = selectionStart;
    record.current.end = selectionEnd;
  }
  const hadSelectionUpdate = (0, _element.useRef)(false);
  if (!record.current) {
    hadSelectionUpdate.current = isSelected;
    setRecordFromProps();
    // Sometimes formats are added programmatically and we need to make
    // sure it's persisted to the block store / markup. If these formats
    // are not applied, they could cause inconsistencies between the data
    // in the visual editor and the frontend. Right now, it's only relevant
    // to the `core/text-color` format, which is applied at runtime in
    // certain circunstances. See the `__unstableFilterAttributeValue`
    // function in `packages/format-library/src/text-color/index.js`.
    // @todo find a less-hacky way of solving this.

    const hasRelevantInitFormat = record.current?.formats[0]?.[0]?.type === 'core/text-color';
    if (hasRelevantInitFormat) {
      handleChangesUponInit(record.current);
    }
  } else if (selectionStart !== record.current.start || selectionEnd !== record.current.end) {
    hadSelectionUpdate.current = isSelected;
    record.current = {
      ...record.current,
      start: selectionStart,
      end: selectionEnd,
      activeFormats: undefined
    };
  }

  /**
   * Sync the value to global state. The node tree and selection will also be
   * updated if differences are found.
   *
   * @param {Object} newRecord The record to sync and apply.
   */
  function handleChange(newRecord) {
    record.current = newRecord;
    applyRecord(newRecord);
    if (disableFormats) {
      _value.current = newRecord.text;
    } else {
      _value.current = (0, _toHtmlString.toHTMLString)({
        value: __unstableBeforeSerialize ? {
          ...newRecord,
          formats: __unstableBeforeSerialize(newRecord)
        } : newRecord,
        preserveWhiteSpace
      });
    }
    const {
      start,
      end,
      formats,
      text
    } = newRecord;

    // Selection must be updated first, so it is recorded in history when
    // the content change happens.
    // We batch both calls to only attempt to rerender once.
    registry.batch(() => {
      onSelectionChange(start, end);
      onChange(_value.current, {
        __unstableFormats: formats,
        __unstableText: text
      });
    });
    forceRender();
  }
  function handleChangesUponInit(newRecord) {
    record.current = newRecord;
    _value.current = (0, _toHtmlString.toHTMLString)({
      value: __unstableBeforeSerialize ? {
        ...newRecord,
        formats: __unstableBeforeSerialize(newRecord)
      } : newRecord,
      preserveWhiteSpace
    });
    const {
      formats,
      text
    } = newRecord;
    registry.batch(() => {
      onChange(_value.current, {
        __unstableFormats: formats,
        __unstableText: text
      });
    });
    forceRender();
  }
  function applyFromProps() {
    setRecordFromProps();
    applyRecord(record.current);
  }
  const didMount = (0, _element.useRef)(false);

  // Value updates must happen synchonously to avoid overwriting newer values.
  (0, _element.useLayoutEffect)(() => {
    if (didMount.current && value !== _value.current) {
      applyFromProps();
      forceRender();
    }
  }, [value]);

  // Value updates must happen synchonously to avoid overwriting newer values.
  (0, _element.useLayoutEffect)(() => {
    if (!hadSelectionUpdate.current) {
      return;
    }
    if (ref.current.ownerDocument.activeElement !== ref.current) {
      ref.current.focus();
    }
    applyRecord(record.current);
    hadSelectionUpdate.current = false;
  }, [hadSelectionUpdate.current]);
  const mergedRefs = (0, _compose.useMergeRefs)([ref, (0, _useDefaultStyle.useDefaultStyle)(), (0, _useBoundaryStyle.useBoundaryStyle)({
    record
  }), (0, _useCopyHandler.useCopyHandler)({
    record,
    preserveWhiteSpace
  }), (0, _useSelectObject.useSelectObject)(), (0, _useFormatBoundaries.useFormatBoundaries)({
    record,
    applyRecord
  }), (0, _useDelete.useDelete)({
    createRecord,
    handleChange
  }), (0, _useInputAndSelection.useInputAndSelection)({
    record,
    applyRecord,
    createRecord,
    handleChange,
    isSelected,
    onSelectionChange
  }), (0, _useSelectionChangeCompat.useSelectionChangeCompat)(), (0, _compose.useRefEffect)(() => {
    applyFromProps();
    didMount.current = true;
  }, [placeholder, ...__unstableDependencies])]);
  return {
    value: record.current,
    // A function to get the most recent value so event handlers in
    // useRichText implementations have access to it. For example when
    // listening to input events, we internally update the state, but this
    // state is not yet available to the input event handler because React
    // may re-render asynchronously.
    getValue: () => record.current,
    onChange: handleChange,
    ref: mergedRefs
  };
}
function __experimentalRichText() {}
//# sourceMappingURL=index.js.map