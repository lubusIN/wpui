import {
  useMenuList
} from "../__chunks/KME3EPVS.js";
import {
  MenuBarContext,
  MenuContext
} from "../__chunks/HVBRRKV4.js";
import "../__chunks/F4XABKPL.js";
import "../__chunks/AAVDGJD5.js";
import "../__chunks/OXPV2NBK.js";
import "../__chunks/WJ37OVG2.js";
import {
  useHovercard
} from "../__chunks/24II2LYU.js";
import "../__chunks/X7FKJQME.js";
import "../__chunks/K5MSER23.js";
import "../__chunks/SZIMOWLA.js";
import "../__chunks/5IZLNERH.js";
import "../__chunks/NHPU54IO.js";
import "../__chunks/GDORSOK6.js";
import "../__chunks/3LAWLNOX.js";
import "../__chunks/CJI67A3R.js";
import "../__chunks/PLOINBVB.js";
import "../__chunks/E5XSMSHD.js";
import "../__chunks/LEBYH5FW.js";
import "../__chunks/IXXFVVA2.js";
import "../__chunks/7JNF6I52.js";
import "../__chunks/KOVUJERF.js";
import "../__chunks/62DFK33R.js";
import "../__chunks/FW6QFGFT.js";
import "../__chunks/IYNN2ZO5.js";
import "../__chunks/5M4ITSXL.js";
import "../__chunks/6OMX4H3W.js";
import "../__chunks/LL3AE4N4.js";
import "../__chunks/EJ3GIT5B.js";
import "../__chunks/LDDPB3PY.js";
import "../__chunks/COQHFAEN.js";
import "../__chunks/LNHZLQEK.js";
import "../__chunks/M5I7AM4N.js";
import "../__chunks/WHEEIXMF.js";
import "../__chunks/6GS36SYX.js";
import "../__chunks/MYID4V27.js";
import "../__chunks/BMLNRUFQ.js";
import "../__chunks/FL2AU7YJ.js";
import {
  createComponent,
  createElement,
  createHook
} from "../__chunks/NQJBHION.js";
import "../__chunks/SWJ5EOOS.js";
import "../__chunks/P63NRZ4A.js";
import {
  useBooleanEvent,
  useEvent,
  useMergeRefs
} from "../__chunks/J7Q2EO23.js";
import "../__chunks/CP3U4HPL.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "../__chunks/PNRLI7OV.js";

// src/menu/menu.ts
import { createRef, useContext, useEffect, useRef, useState } from "react";
import { hasFocusWithin } from "@ariakit/core/utils/focus";
var useMenu = createHook(
  (_a) => {
    var _b = _a, {
      store,
      hideOnEscape = true,
      autoFocusOnShow = true,
      hideOnHoverOutside,
      alwaysVisible
    } = _b, props = __objRest(_b, [
      "store",
      "hideOnEscape",
      "autoFocusOnShow",
      "hideOnHoverOutside",
      "alwaysVisible"
    ]);
    const ref = useRef(null);
    const parentMenu = useContext(MenuContext);
    const parentMenuBar = useContext(MenuBarContext);
    const hasParentMenu = !!parentMenu;
    const parentIsMenuBar = !!parentMenuBar && !hasParentMenu;
    const onKeyDownProp = props.onKeyDown;
    const hideOnEscapeProp = useBooleanEvent(hideOnEscape);
    const onKeyDown = useEvent((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.key === "Escape") {
        if (!hideOnEscapeProp(event))
          return;
        if (!hasParentMenu) {
          event.stopPropagation();
        }
        return store.hide();
      }
    });
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref),
      onKeyDown
    });
    const _a2 = useMenuList(
      __spreadValues({ store, alwaysVisible }, props)
    ), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = __objRest(_a2, ["aria-labelledby"]);
    props = menuListProps;
    const [initialFocusRef, setInitialFocusRef] = useState();
    const autoFocusOnShowState = store.useState("autoFocusOnShow");
    const initialFocus = store.useState("initialFocus");
    const baseElement = store.useState("baseElement");
    const items = store.useState("renderedItems");
    useEffect(() => {
      let cleaning = false;
      setInitialFocusRef((prevInitialFocusRef) => {
        var _a3, _b2, _c;
        if (cleaning)
          return;
        if (!autoFocusOnShowState)
          return;
        if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected)
          return prevInitialFocusRef;
        const ref2 = createRef();
        switch (initialFocus) {
          case "first":
            ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
            break;
          case "last":
            ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
            break;
          default:
            ref2.current = baseElement;
        }
        if (!ref2.current)
          return;
        return ref2;
      });
      return () => {
        cleaning = true;
      };
    }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!props.modal;
    props = useHovercard(__spreadProps(__spreadValues({
      store,
      alwaysVisible,
      initialFocus: initialFocusRef,
      autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!props.modal
    }, props), {
      hideOnHoverOutside: (event) => {
        if (typeof hideOnHoverOutside === "function") {
          return hideOnHoverOutside(event);
        }
        if (hideOnHoverOutside != null)
          return hideOnHoverOutside;
        if (hasParentMenu) {
          parentMenu.setActiveId(null);
          return true;
        }
        if (!parentIsMenuBar)
          return false;
        const { disclosureElement } = store.getState();
        const disclosure = disclosureElement;
        if (!disclosure)
          return true;
        if (hasFocusWithin(disclosure))
          return false;
        return true;
      },
      // If it's a submenu, it shouldn't behave like a modal dialog, nor display
      // a backdrop.
      modal: hasParentMenu ? false : props.modal,
      backdrop: hasParentMenu ? false : props.backdrop,
      // If it's a submenu, hide on esc will be handled differently. That is,
      // event.stopPropagation() won't be called, so the parent menus will also
      // be closed.
      hideOnEscape: hasParentMenu ? false : hideOnEscape
    }));
    props = __spreadValues({
      "aria-labelledby": ariaLabelledBy
    }, props);
    return props;
  }
);
var Menu = createComponent((props) => {
  const htmlProps = useMenu(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Menu.displayName = "Menu";
}
export {
  Menu,
  useMenu
};
