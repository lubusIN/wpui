import {
  getElementPolygon,
  getEventPoint,
  isPointInPolygon
} from "./X7FKJQME.js";
import {
  usePopover
} from "./K5MSER23.js";
import {
  createComponent,
  createElement,
  createHook
} from "./NQJBHION.js";
import {
  useBooleanEvent,
  useEvent,
  useLiveRef,
  useMergeRefs,
  usePortalRef,
  useSafeLayoutEffect,
  useWrapElement
} from "./J7Q2EO23.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/hovercard/hovercard.tsx
import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState
} from "react";
import { contains } from "@ariakit/core/utils/dom";
import { addGlobalEventListener } from "@ariakit/core/utils/events";
import { hasFocusWithin } from "@ariakit/core/utils/focus";
import { chain, isFalsyBooleanCallback } from "@ariakit/core/utils/misc";
import { sync } from "@ariakit/core/utils/store";
import { jsx } from "react/jsx-runtime";
function isMovingOnHovercard(target, card, anchor, nested) {
  if (hasFocusWithin(card))
    return true;
  if (!target)
    return false;
  if (contains(card, target))
    return true;
  if (anchor && contains(anchor, target))
    return true;
  if (nested == null ? void 0 : nested.some((card2) => isMovingOnHovercard(target, card2, anchor))) {
    return true;
  }
  return false;
}
function useAutoFocusOnShow(_a) {
  var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
  const open = store.useState("open");
  const openRef = useLiveRef(open);
  useEffect(() => {
    if (!open) {
      store.setAutoFocusOnShow(false);
    }
  }, [open, store]);
  useEffect(
    () => () => {
      if (!openRef.current) {
        store.setAutoFocusOnShow(false);
      }
    },
    [store]
  );
  const modal = !!props.modal;
  const autoFocusOnShow = store.useState(
    (state) => modal || state.autoFocusOnShow
  );
  return __spreadValues({ autoFocusOnShow }, props);
}
function useAutoFocusOnHide(_a) {
  var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
  const [autoFocusOnHide, setAutoFocusOnHide] = useState(false);
  const mounted = store.useState("mounted");
  useEffect(() => {
    if (!mounted) {
      setAutoFocusOnHide(false);
    }
  }, [mounted]);
  const onFocusProp = props.onFocus;
  const onFocus = useEvent((event) => {
    onFocusProp == null ? void 0 : onFocusProp(event);
    if (event.defaultPrevented)
      return;
    setAutoFocusOnHide(true);
  });
  const finalFocusRef = useRef(null);
  useEffect(() => {
    return sync(store, ["anchorElement"], (state) => {
      finalFocusRef.current = state.anchorElement;
    });
  }, []);
  props = __spreadProps(__spreadValues({
    autoFocusOnHide,
    finalFocus: finalFocusRef
  }, props), {
    onFocus
  });
  return props;
}
var NestedHovercardContext = createContext(null);
var useHovercard = createHook(
  (_a) => {
    var _b = _a, {
      store,
      modal = false,
      portal = !!modal,
      hideOnEscape = true,
      hideOnHoverOutside = true,
      disablePointerEventsOnApproach = !!hideOnHoverOutside
    } = _b, props = __objRest(_b, [
      "store",
      "modal",
      "portal",
      "hideOnEscape",
      "hideOnHoverOutside",
      "disablePointerEventsOnApproach"
    ]);
    const ref = useRef(null);
    const [nestedHovercards, setNestedHovercards] = useState([]);
    const hideTimeoutRef = useRef(0);
    const enterPointRef = useRef(null);
    const { portalRef, domReady } = usePortalRef(portal, props.portalRef);
    const mayHideOnHoverOutside = !!hideOnHoverOutside;
    const hideOnHoverOutsideProp = useBooleanEvent(hideOnHoverOutside);
    const mayDisablePointerEvents = !!disablePointerEventsOnApproach;
    const disablePointerEventsProp = useBooleanEvent(
      disablePointerEventsOnApproach
    );
    const mounted = store.useState("mounted");
    useEffect(() => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      if (!mayHideOnHoverOutside && !mayDisablePointerEvents)
        return;
      const element = ref.current;
      if (!element)
        return;
      const onMouseMove = (event) => {
        const { anchorElement, hideTimeout, timeout } = store.getState();
        const enterPoint = enterPointRef.current;
        const target = event.target;
        const anchor = anchorElement;
        if (isMovingOnHovercard(target, element, anchor, nestedHovercards)) {
          enterPointRef.current = target && anchor && contains(anchor, target) ? getEventPoint(event) : null;
          window.clearTimeout(hideTimeoutRef.current);
          hideTimeoutRef.current = 0;
          return;
        }
        if (hideTimeoutRef.current)
          return;
        if (enterPoint) {
          const currentPoint = getEventPoint(event);
          const polygon = getElementPolygon(element, enterPoint);
          if (isPointInPolygon(currentPoint, polygon)) {
            enterPointRef.current = currentPoint;
            if (!disablePointerEventsProp(event))
              return;
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
        if (!hideOnHoverOutsideProp(event))
          return;
        hideTimeoutRef.current = window.setTimeout(() => {
          hideTimeoutRef.current = 0;
          store.hide();
        }, hideTimeout != null ? hideTimeout : timeout);
      };
      return chain(
        addGlobalEventListener("mousemove", onMouseMove, true),
        () => clearTimeout(hideTimeoutRef.current)
      );
    }, [
      store,
      domReady,
      mounted,
      mayHideOnHoverOutside,
      mayDisablePointerEvents,
      nestedHovercards,
      disablePointerEventsProp,
      hideOnHoverOutsideProp
    ]);
    useEffect(() => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      if (!mayDisablePointerEvents)
        return;
      const disableEvent = (event) => {
        const element = ref.current;
        if (!element)
          return;
        const enterPoint = enterPointRef.current;
        if (!enterPoint)
          return;
        const polygon = getElementPolygon(element, enterPoint);
        if (isPointInPolygon(getEventPoint(event), polygon)) {
          if (!disablePointerEventsProp(event))
            return;
          event.preventDefault();
          event.stopPropagation();
        }
      };
      return chain(
        // Note: we may need to add pointer events here in the future.
        addGlobalEventListener("mouseenter", disableEvent, true),
        addGlobalEventListener("mouseover", disableEvent, true),
        addGlobalEventListener("mouseout", disableEvent, true),
        addGlobalEventListener("mouseleave", disableEvent, true)
      );
    }, [domReady, mounted, mayDisablePointerEvents, disablePointerEventsProp]);
    const registerOnParent = useContext(NestedHovercardContext);
    useSafeLayoutEffect(() => {
      if (modal)
        return;
      if (!portal)
        return;
      if (!mounted)
        return;
      if (!domReady)
        return;
      const element = ref.current;
      if (!element)
        return;
      return registerOnParent == null ? void 0 : registerOnParent(element);
    }, [modal, portal, mounted, domReady]);
    const registerNestedHovercard = useCallback(
      (element) => {
        setNestedHovercards((prevElements) => [...prevElements, element]);
        const parentUnregister = registerOnParent == null ? void 0 : registerOnParent(element);
        return () => {
          setNestedHovercards(
            (prevElements) => prevElements.filter((item) => item !== element)
          );
          parentUnregister == null ? void 0 : parentUnregister();
        };
      },
      [registerOnParent]
    );
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(NestedHovercardContext.Provider, { value: registerNestedHovercard, children: element }),
      [registerNestedHovercard]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref)
    });
    props = useAutoFocusOnHide(__spreadValues({ store }, props));
    props = useAutoFocusOnShow(__spreadValues({ store, modal }, props));
    props = usePopover(__spreadProps(__spreadValues({
      store,
      modal,
      portal
    }, props), {
      portalRef,
      hideOnEscape(event) {
        if (isFalsyBooleanCallback(hideOnEscape, event))
          return false;
        requestAnimationFrame(() => requestAnimationFrame(store.hide));
        return true;
      }
    }));
    return props;
  }
);
var Hovercard = createComponent((props) => {
  const htmlProps = useHovercard(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Hovercard.displayName = "Hovercard";
}

export {
  useHovercard,
  Hovercard
};
