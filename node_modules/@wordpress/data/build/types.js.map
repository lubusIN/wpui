{"version":3,"names":[],"sources":["@wordpress/data/src/types.ts"],"sourcesContent":["/**\n * External dependencies\n */\n// eslint-disable-next-line no-restricted-imports\nimport type { combineReducers as reduxCombineReducers } from 'redux';\n\ntype MapOf< T > = { [ name: string ]: T };\n\nexport type ActionCreator = ( ...args: any[] ) => any | Generator;\nexport type Resolver = Function | Generator;\nexport type Selector = Function;\n\nexport type AnyConfig = ReduxStoreConfig< any, any, any >;\n\nexport interface StoreInstance< Config extends AnyConfig > {\n\tgetSelectors: () => SelectorsOf< Config >;\n\tgetActions: () => ActionCreatorsOf< Config >;\n\tsubscribe: ( listener: () => void ) => () => void;\n}\n\nexport interface StoreDescriptor< Config extends AnyConfig > {\n\t/**\n\t * Store Name\n\t */\n\tname: string;\n\n\t/**\n\t * Creates a store instance\n\t */\n\tinstantiate: ( registry: DataRegistry ) => StoreInstance< Config >;\n}\n\nexport interface ReduxStoreConfig<\n\tState,\n\tActionCreators extends MapOf< ActionCreator >,\n\tSelectors,\n> {\n\tinitialState?: State;\n\treducer: ( state: any, action: any ) => any;\n\tactions?: ActionCreators;\n\tresolvers?: MapOf< Resolver >;\n\tselectors?: Selectors;\n\tcontrols?: MapOf< Function >;\n}\n\n// Return type for the useSelect() hook.\nexport type UseSelectReturn< F extends MapSelect | StoreDescriptor< any > > =\n\tF extends MapSelect\n\t\t? ReturnType< F >\n\t\t: F extends StoreDescriptor< any >\n\t\t? CurriedSelectorsOf< F >\n\t\t: never;\n\n// Return type for the useDispatch() hook.\nexport type UseDispatchReturn< StoreNameOrDescriptor > =\n\tStoreNameOrDescriptor extends StoreDescriptor< any >\n\t\t? ActionCreatorsOf< ConfigOf< StoreNameOrDescriptor > >\n\t\t: StoreNameOrDescriptor extends undefined\n\t\t? DispatchFunction\n\t\t: any;\n\nexport type DispatchFunction = < StoreNameOrDescriptor >(\n\tstore: StoreNameOrDescriptor\n) => DispatchReturn< StoreNameOrDescriptor >;\n\nexport type DispatchReturn< StoreNameOrDescriptor > =\n\tStoreNameOrDescriptor extends StoreDescriptor< any >\n\t\t? ActionCreatorsOf< ConfigOf< StoreNameOrDescriptor > >\n\t\t: unknown;\n\nexport type MapSelect = (\n\tselect: SelectFunction,\n\tregistry: DataRegistry\n) => any;\n\nexport type SelectFunction = < S >( store: S ) => CurriedSelectorsOf< S >;\n\n/**\n * Callback for store's `subscribe()` method that\n * runs when the store data has changed.\n */\nexport type ListenerFunction = () => void;\n\nexport type CurriedSelectorsOf< S > = S extends StoreDescriptor<\n\tReduxStoreConfig< any, any, infer Selectors >\n>\n\t? { [ key in keyof Selectors ]: CurriedState< Selectors[ key ] > }\n\t: never;\n\n/**\n * Removes the first argument from a function.\n *\n * By default, it removes the `state` parameter from\n * registered selectors since that argument is supplied\n * by the editor when calling `select(â€¦)`.\n *\n * For functions with no arguments, which some selectors\n * are free to define, returns the original function.\n *\n * It is possible to manually provide a custom curried signature\n * and avoid the automatic inference. When the\n * F generic argument passed to this helper extends the\n * SelectorWithCustomCurrySignature type, the F['CurriedSignature']\n * property is used verbatim.\n *\n * This is useful because TypeScript does not correctly remove\n * arguments from complex function signatures constrained by\n * interdependent generic parameters.\n * For more context, see https://github.com/WordPress/gutenberg/pull/41578\n */\ntype CurriedState< F > = F extends SelectorWithCustomCurrySignature\n\t? F[ 'CurriedSignature' ]\n\t: F extends ( state: any, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\n\n/**\n * Utility to manually specify curried selector signatures.\n *\n * It comes handy when TypeScript can't automatically produce the\n * correct curried function signature. For example:\n *\n * ```ts\n * type BadlyInferredSignature = CurriedState<\n *     <K extends string | number>(\n *         state: any,\n *         kind: K,\n *         key: K extends string ? 'one value' : false\n *     ) => K\n * >\n * // BadlyInferredSignature evaluates to:\n * // (kind: string number, key: false \"one value\") => string number\n * ```\n *\n * With SelectorWithCustomCurrySignature, we can provide a custom\n * signature and avoid relying on TypeScript inference:\n * ```ts\n * interface MySelectorSignature extends SelectorWithCustomCurrySignature {\n *     <K extends string | number>(\n *         state: any,\n *         kind: K,\n *         key: K extends string ? 'one value' : false\n *     ): K;\n *\n *     CurriedSignature: <K extends string | number>(\n *         kind: K,\n *         key: K extends string ? 'one value' : false\n *     ): K;\n * }\n * type CorrectlyInferredSignature = CurriedState<MySelectorSignature>\n * // <K extends string | number>(kind: K, key: K extends string ? 'one value' : false): K;\n *\n * For even more context, see https://github.com/WordPress/gutenberg/pull/41578\n * ```\n */\nexport interface SelectorWithCustomCurrySignature {\n\tCurriedSignature: Function;\n}\n\nexport interface DataRegistry {\n\tregister: ( store: StoreDescriptor< any > ) => void;\n}\n\nexport interface DataEmitter {\n\temit: () => void;\n\tsubscribe: ( listener: () => void ) => () => void;\n\tpause: () => void;\n\tresume: () => void;\n\tisPaused: boolean;\n}\n\n// Type Helpers.\n\nexport type ConfigOf< S > = S extends StoreDescriptor< infer C > ? C : never;\n\nexport type ActionCreatorsOf< Config extends AnyConfig > =\n\tConfig extends ReduxStoreConfig< any, infer ActionCreators, any >\n\t\t? PromisifiedActionCreators< ActionCreators >\n\t\t: never;\n\n// Takes an object containing all action creators for a store and updates the\n// return type of each action creator to account for internal registry details --\n// for example, dispatched actions are wrapped with a Promise.\nexport type PromisifiedActionCreators<\n\tActionCreators extends MapOf< ActionCreator >,\n> = {\n\t[ Action in keyof ActionCreators ]: PromisifyActionCreator<\n\t\tActionCreators[ Action ]\n\t>;\n};\n\n// Wraps action creator return types with a Promise and handles thunks.\nexport type PromisifyActionCreator< Action extends ActionCreator > = (\n\t...args: Parameters< Action >\n) => Promise<\n\tReturnType< Action > extends ( ..._args: any[] ) => any\n\t\t? ThunkReturnType< Action >\n\t\t: ReturnType< Action >\n>;\n\n// A thunk is an action creator which returns a function, which can optionally\n// return a Promise. The double ReturnType unwraps the innermost function's\n// return type, and Awaited gets the type the Promise resolves to. If the return\n// type is not a Promise, Awaited returns that original type.\nexport type ThunkReturnType< Action extends ActionCreator > = Awaited<\n\tReturnType< ReturnType< Action > >\n>;\n\ntype SelectorsOf< Config extends AnyConfig > = Config extends ReduxStoreConfig<\n\tany,\n\tany,\n\tinfer Selectors\n>\n\t? { [ name in keyof Selectors ]: Function }\n\t: never;\n\nexport type combineReducers = typeof reduxCombineReducers;\n"],"mappings":""}