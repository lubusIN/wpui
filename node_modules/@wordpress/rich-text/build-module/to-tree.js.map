{"version":3,"names":["getActiveFormats","getFormatType","OBJECT_REPLACEMENT_CHARACTER","ZWNBSP","restoreOnAttributes","attributes","isEditableTree","newAttributes","key","newKey","startsWith","slice","length","fromFormat","type","tagName","unregisteredAttributes","object","boundaryClass","formatType","elementAttributes","name","className","class","contentEditable","contenteditable","isEqualUntil","a","b","index","toTree","value","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","formats","replacements","text","start","end","formatsLength","tree","activeFormats","deepestActiveFormat","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","characterFormats","pointer","forEach","format","formatIndex","parent","newNode","replacement","innerHTML","html","decodeURIComponent","undefined","style"],"sources":["@wordpress/rich-text/src/to-tree.js"],"sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"],"mappings":"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"}