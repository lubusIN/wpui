import {
  useFocusable
} from "./MYID4V27.js";
import {
  createComponent,
  createElement,
  createHook
} from "./NQJBHION.js";
import {
  useEvent,
  useMergeRefs,
  useTagName
} from "./J7Q2EO23.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/command/command.ts
import { useEffect, useRef, useState } from "react";
import { isButton, isTextField } from "@ariakit/core/utils/dom";
import {
  fireClickEvent,
  isSelfTarget,
  queueBeforeEvent
} from "@ariakit/core/utils/events";
import { isFirefox } from "@ariakit/core/utils/platform";
function isNativeClick(event) {
  if (!event.isTrusted)
    return false;
  const element = event.currentTarget;
  if (event.key === "Enter") {
    return isButton(element) || element.tagName === "SUMMARY" || element.tagName === "A";
  }
  if (event.key === " ") {
    return isButton(element) || element.tagName === "SUMMARY" || element.tagName === "INPUT" || element.tagName === "SELECT";
  }
  return false;
}
var useCommand = createHook(
  (_a) => {
    var _b = _a, { clickOnEnter = true, clickOnSpace = true } = _b, props = __objRest(_b, ["clickOnEnter", "clickOnSpace"]);
    const ref = useRef(null);
    const tagName = useTagName(ref, props.as);
    const type = props.type;
    const [isNativeButton, setIsNativeButton] = useState(
      () => !!tagName && isButton({ tagName, type })
    );
    useEffect(() => {
      if (!ref.current)
        return;
      setIsNativeButton(isButton(ref.current));
    }, []);
    const [active, setActive] = useState(false);
    const activeRef = useRef(false);
    const isDuplicate = "data-command" in props;
    const onKeyDownProp = props.onKeyDown;
    const onKeyDown = useEvent((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      const element = event.currentTarget;
      if (event.defaultPrevented)
        return;
      if (isDuplicate)
        return;
      if (props.disabled)
        return;
      if (!isSelfTarget(event))
        return;
      if (isTextField(element))
        return;
      if (element.isContentEditable)
        return;
      const isEnter = clickOnEnter && event.key === "Enter";
      const isSpace = clickOnSpace && event.key === " ";
      const shouldPreventEnter = event.key === "Enter" && !clickOnEnter;
      const shouldPreventSpace = event.key === " " && !clickOnSpace;
      if (shouldPreventEnter || shouldPreventSpace) {
        event.preventDefault();
        return;
      }
      if (isEnter || isSpace) {
        const nativeClick = isNativeClick(event);
        if (isEnter) {
          if (!nativeClick) {
            event.preventDefault();
            const _a2 = event, { view } = _a2, eventInit = __objRest(_a2, ["view"]);
            const click = () => fireClickEvent(element, eventInit);
            if (isFirefox()) {
              queueBeforeEvent(element, "keyup", click);
            } else {
              queueMicrotask(click);
            }
          }
        } else if (isSpace) {
          activeRef.current = true;
          if (!nativeClick) {
            event.preventDefault();
            setActive(true);
          }
        }
      }
    });
    const onKeyUpProp = props.onKeyUp;
    const onKeyUp = useEvent((event) => {
      onKeyUpProp == null ? void 0 : onKeyUpProp(event);
      if (event.defaultPrevented)
        return;
      if (isDuplicate)
        return;
      if (props.disabled)
        return;
      if (event.metaKey)
        return;
      const isSpace = clickOnSpace && event.key === " ";
      if (activeRef.current && isSpace) {
        activeRef.current = false;
        if (!isNativeClick(event)) {
          setActive(false);
          const element = event.currentTarget;
          const _a2 = event, { view } = _a2, eventInit = __objRest(_a2, ["view"]);
          queueMicrotask(() => fireClickEvent(element, eventInit));
        }
      }
    });
    props = __spreadProps(__spreadValues({
      "data-command": "",
      "data-active": active ? "" : void 0,
      type: isNativeButton ? "button" : void 0
    }, props), {
      ref: useMergeRefs(ref, props.ref),
      onKeyDown,
      onKeyUp
    });
    props = useFocusable(props);
    return props;
  }
);
var Command = createComponent((props) => {
  props = useCommand(props);
  return createElement("button", props);
});
if (process.env.NODE_ENV !== "production") {
  Command.displayName = "Command";
}

export {
  useCommand,
  Command
};
