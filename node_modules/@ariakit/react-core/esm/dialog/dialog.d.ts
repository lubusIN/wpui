import type { ComponentPropsWithRef, ElementType, ReactElement, KeyboardEvent as ReactKeyboardEvent, RefObject, SyntheticEvent } from "react";
import type { BooleanOrCallback } from "@ariakit/core/utils/types";
import type { DisclosureContentOptions } from "../disclosure/disclosure-content.js";
import type { FocusableOptions } from "../focusable/focusable.js";
import type { PortalOptions } from "../portal/portal.js";
import type { As, Props } from "../utils/types.js";
import type { DialogStore } from "./dialog-store.js";
/**
 * Returns props to create a `Dialog` component.
 * @see https://ariakit.org/components/dialog
 * @example
 * ```jsx
 * const store = useDialogStore();
 * const props = useDialog({ store });
 * <Role {...props}>Dialog</Role>
 * ```
 */
export declare const useDialog: import("../utils/types.js").Hook<DialogOptions<"div">>;
/**
 * Renders a dialog element.
 * @see https://ariakit.org/components/dialog
 * @example
 * ```jsx
 * const dialog = useDialogStore();
 * <button onClick={dialog.toggle}>Open dialog</button>
 * <Dialog store={dialog}>Dialog</Dialog>
 * ```
 */
export declare const Dialog: import("../utils/types.js").Component<DialogOptions<"div">>;
export interface DialogOptions<T extends As = "div"> extends FocusableOptions<T>, PortalOptions<T>, DisclosureContentOptions<T> {
    /**
     * Object returned by the `useDialogStore` hook.
     */
    store: DialogStore;
    /**
     * Determines whether the dialog is modal. Modal dialogs have distinct states
     * and behaviors:
     * - The `portal` and `preventBodyScroll` props are set to `true`. They can
     *   still be manually set to `false`.
     * - A visually hidden dismiss button will be rendered if the `DialogDismiss`
     *   component hasn't been used. This allows screen reader users to close the
     *   dialog.
     * - When the dialog is open, element tree outside it will be disabled.
     * - When using the `Heading` or `DialogHeading` components within the dialog,
     *   their level will be reset so they start with `h1`.
     * @default true
     */
    modal?: boolean;
    /**
     * Determines whether there will be a backdrop behind the dialog. On modal
     * dialogs, this is `true` by default. Besides a `boolean`, this prop can also
     * be a React component or JSX element that will be rendered as the backdrop.
     *
     * **If a custom component is used, it must accept ref and spread all props to
     * its underlying DOM element**, the same way a native element would.
     *
     * Live examples:
     * - [Animated Dialog](https://ariakit.org/examples/dialog-animated)
     * - [Dialog with scrollable
     *   backdrop](https://ariakit.org/examples/dialog-backdrop-scrollable)
     * - [Dialog with Framer
     *   Motion](https://ariakit.org/examples/dialog-framer-motion)
     * - [Dialog with Menu](https://ariakit.org/examples/dialog-menu)
     * - [Nested Dialog](https://ariakit.org/examples/dialog-nested)
     * - [Dialog with Next.js App
     *   Router](https://ariakit.org/examples/dialog-next-router)
     * @example
     * ```jsx
     * <Dialog backdrop={<div className="backdrop" />} />
     * ```
     */
    backdrop?: boolean | ReactElement<ComponentPropsWithRef<"div">> | ElementType<ComponentPropsWithRef<"div">>;
    /**
     * Props that will be passed to the backdrop element if
     * [`backdrop`](https://ariakit.org/reference/dialog#backdrop) is `true`.
     * @deprecated Use the
     * [`backdrop`](https://ariakit.org/reference/dialog#backdrop) prop instead.
     */
    backdropProps?: ComponentPropsWithRef<"div">;
    /**
     * Determines whether the dialog will be hidden when the user presses the
     * Escape key.
     * @default true
     */
    hideOnEscape?: BooleanOrCallback<KeyboardEvent | ReactKeyboardEvent>;
    /**
     * Determines whether the dialog will be hidden when the user clicks or focus
     * on an element outside of the dialog.
     * @default true
     */
    hideOnInteractOutside?: BooleanOrCallback<Event | SyntheticEvent>;
    /**
     * When a dialog is open, the elements outside of it will be disabled so they
     * can't be interacted with if the dialog is modal. For non-modal dialogs,
     * interacting with elements outside of the dialog will close it. With this
     * function, you can return a collection of elements that will be considered
     * part of the dialog and therefore will be excluded from this behavior.
     *
     * Live examples:
     * - [Dialog with
     *   React-Toastify](https://ariakit.org/examples/dialog-react-toastify)
     */
    getPersistentElements?: () => Iterable<Element>;
    /**
     * Determines whether the body scrolling will be prevented when the dialog is
     * shown.
     */
    preventBodyScroll?: boolean;
    /**
     * Determines whether an element inside the dialog will receive focus when the
     * dialog is shown. By default, this is usually the first tabbable element in
     * the dialog or the dialog itself. The `initialFocus` prop can be used to set
     * a different element to receive focus.
     * @default true
     */
    autoFocusOnShow?: BooleanOrCallback<HTMLElement | null>;
    /**
     * Determines whether an element outside of the dialog will be focused when
     * the dialog is hidden if another element hasn't been focused in the action
     * of hiding the dialog (for example, by clicking or tabbing into another
     * tabbable element outside of the dialog). By default, this is usually the
     * disclosure element. The `finalFocus` prop can be used to define a different
     * element to be focused.
     * @default true
     */
    autoFocusOnHide?: BooleanOrCallback<HTMLElement | null>;
    /**
     * Specifies the element that will receive focus when the dialog is first
     * opened. It can be an `HTMLElement` or a `React.RefObject` with an
     * `HTMLElement`. However, if `autoFocusOnShow` is set to `false`, this prop
     * will have no effect. If left unset, the dialog will attempt to determine
     * the initial focus element in the following order:
     * 1. An element with an `autoFocus` prop.
     * 2. The first tabbable element inside the dialog.
     * 3. The first focusable element inside the dialog.
     * 4. The dialog element itself.
     */
    initialFocus?: HTMLElement | RefObject<HTMLElement> | null;
    /**
     * Determines the element that will receive focus once the dialog is closed,
     * provided that no other element has been focused while the dialog was being
     * hidden (e.g., by clicking or tabbing into another tabbable element outside
     * of the dialog). However, if `autoFocusOnHide` is set to `false`, this prop
     * will have no effect. If left unset, the element that was focused before the
     * dialog was opened will be focused again.
     */
    finalFocus?: HTMLElement | RefObject<HTMLElement> | null;
}
export type DialogProps<T extends As = "div"> = Props<DialogOptions<T>>;
