{"version":3,"names":["normaliseFormats","replace","array","index","value","slice","applyFormat","format","startIndex","start","endIndex","end","formats","activeFormats","newFormats","startFormat","find","type","indexOf","position","Infinity","filter","length","splice"],"sources":["@wordpress/rich-text/src/apply-format.js"],"sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === format.type\n\t\t);\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...( activeFormats?.filter(\n\t\t\t\t( { type } ) => type !== format.type\n\t\t\t) || [] ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n"],"mappings":"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"}