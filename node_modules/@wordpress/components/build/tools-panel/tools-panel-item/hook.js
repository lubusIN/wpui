"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToolsPanelItem = useToolsPanelItem;
var _compose = require("@wordpress/compose");
var _element = require("@wordpress/element");
var styles = _interopRequireWildcard(require("../styles"));
var _context = require("../context");
var _context2 = require("../../ui/context");
var _useCx = require("../../utils/hooks/use-cx");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const noop = () => {};
function useToolsPanelItem(props) {
  const {
    className,
    hasValue,
    isShownByDefault = false,
    label,
    panelId,
    resetAllFilter = noop,
    onDeselect,
    onSelect,
    ...otherProps
  } = (0, _context2.useContextSystem)(props, 'ToolsPanelItem');
  const {
    panelId: currentPanelId,
    menuItems,
    registerResetAllFilter,
    deregisterResetAllFilter,
    registerPanelItem,
    deregisterPanelItem,
    flagItemCustomization,
    isResetting,
    shouldRenderPlaceholderItems: shouldRenderPlaceholder,
    firstDisplayedItem,
    lastDisplayedItem,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  } = (0, _context.useToolsPanelContext)();
  const hasValueCallback = (0, _element.useCallback)(hasValue, [panelId, hasValue]);
  const resetAllFilterCallback = (0, _element.useCallback)(resetAllFilter, [panelId, resetAllFilter]);
  const previousPanelId = (0, _compose.usePrevious)(currentPanelId);
  const hasMatchingPanel = currentPanelId === panelId || currentPanelId === null;

  // Registering the panel item allows the panel to include it in its
  // automatically generated menu and determine its initial checked status.
  (0, _element.useEffect)(() => {
    if (hasMatchingPanel && previousPanelId !== null) {
      registerPanelItem({
        hasValue: hasValueCallback,
        isShownByDefault,
        label,
        panelId
      });
    }
    return () => {
      if (previousPanelId === null && !!currentPanelId || currentPanelId === panelId) {
        deregisterPanelItem(label);
      }
    };
  }, [currentPanelId, hasMatchingPanel, isShownByDefault, label, hasValueCallback, panelId, previousPanelId, registerPanelItem, deregisterPanelItem]);
  (0, _element.useEffect)(() => {
    if (hasMatchingPanel) {
      registerResetAllFilter(resetAllFilterCallback);
    }
    return () => {
      if (hasMatchingPanel) {
        deregisterResetAllFilter(resetAllFilterCallback);
      }
    };
  }, [registerResetAllFilter, deregisterResetAllFilter, resetAllFilterCallback, hasMatchingPanel]);

  // Note: `label` is used as a key when building menu item state in
  // `ToolsPanel`.
  const menuGroup = isShownByDefault ? 'default' : 'optional';
  const isMenuItemChecked = menuItems?.[menuGroup]?.[label];
  const wasMenuItemChecked = (0, _compose.usePrevious)(isMenuItemChecked);
  const isRegistered = menuItems?.[menuGroup]?.[label] !== undefined;
  const isValueSet = hasValue();
  const wasValueSet = (0, _compose.usePrevious)(isValueSet);
  const newValueSet = isValueSet && !wasValueSet;

  // Notify the panel when an item's value has been set.
  //
  // 1. For default controls, this is so "reset" appears beside its menu item.
  // 2. For optional controls, when the panel ID is `null`, it allows the
  // panel to ensure the item is toggled on for display in the menu, given the
  // value has been set external to the control.
  (0, _element.useEffect)(() => {
    if (!newValueSet) {
      return;
    }
    if (isShownByDefault || currentPanelId === null) {
      flagItemCustomization(label, menuGroup);
    }
  }, [currentPanelId, newValueSet, isShownByDefault, menuGroup, label, flagItemCustomization]);

  // Determine if the panel item's corresponding menu is being toggled and
  // trigger appropriate callback if it is.
  (0, _element.useEffect)(() => {
    // We check whether this item is currently registered as items rendered
    // via fills can persist through the parent panel being remounted.
    // See: https://github.com/WordPress/gutenberg/pull/45673
    if (!isRegistered || isResetting || !hasMatchingPanel) {
      return;
    }
    if (isMenuItemChecked && !isValueSet && !wasMenuItemChecked) {
      onSelect?.();
    }
    if (!isMenuItemChecked && wasMenuItemChecked) {
      onDeselect?.();
    }
  }, [hasMatchingPanel, isMenuItemChecked, isRegistered, isResetting, isValueSet, wasMenuItemChecked, onSelect, onDeselect]);

  // The item is shown if it is a default control regardless of whether it
  // has a value. Optional items are shown when they are checked or have
  // a value.
  const isShown = isShownByDefault ? menuItems?.[menuGroup]?.[label] !== undefined : isMenuItemChecked;
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)(() => {
    const placeholderStyle = shouldRenderPlaceholder && !isShown && styles.ToolsPanelItemPlaceholder;
    const firstItemStyle = firstDisplayedItem === label && __experimentalFirstVisibleItemClass;
    const lastItemStyle = lastDisplayedItem === label && __experimentalLastVisibleItemClass;
    return cx(styles.ToolsPanelItem, placeholderStyle, className, firstItemStyle, lastItemStyle);
  }, [isShown, shouldRenderPlaceholder, className, cx, firstDisplayedItem, lastDisplayedItem, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass, label]);
  return {
    ...otherProps,
    isShown,
    shouldRenderPlaceholder,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map