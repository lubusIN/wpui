import type { CollectionStoreFunctions, CollectionStoreItem, CollectionStoreOptions, CollectionStoreState } from "../collection/collection-store.js";
import type { Store, StoreOptions, StoreProps } from "../utils/store.js";
import type { SetState } from "../utils/types.js";
type Orientation = "horizontal" | "vertical" | "both";
type Item = CollectionStoreItem & {
    rowId?: string;
    disabled?: boolean;
    children?: string;
};
/**
 * Creates a composite store.
 */
export declare function createCompositeStore<T extends Item = Item>(props?: CompositeStoreProps<T>): CompositeStore<T>;
export type CompositeStoreOrientation = Orientation;
export type CompositeStoreItem = Item;
export interface CompositeStoreState<T extends Item = Item> extends CollectionStoreState<T> {
    /**
     * The composite element.
     */
    baseElement: HTMLElement | null;
    /**
     * If enabled, the composite element will act as an
     * [aria-activedescendant](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant)
     * container instead of [roving
     * tabindex](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex).
     * DOM focus will remain on the composite element while its items receive
     * virtual focus.
     *
     * Live examples:
     * - [Multi-selectable
     *   Combobox](https://ariakit.org/examples/combobox-multiple)
     * @default false
     */
    virtualFocus: boolean;
    /**
     * Defines the orientation of the composite widget. If the composite has a
     * single row or column (one-dimensional), the `orientation` value determines
     * which arrow keys can be used to move focus:
     * - `both`: all arrow keys work.
     * - `horizontal`: only left and right arrow keys work.
     * - `vertical`: only up and down arrow keys work.
     *
     * It doesn't have any effect on two-dimensional composites.
     * @default "both"
     */
    orientation: Orientation;
    /**
     * Determines how the `next` and `previous` functions will behave. If `rtl` is
     * set to `true`, they will be inverted. This only affects the composite
     * widget behavior. You still need to set `dir="rtl"` on HTML/CSS.
     * @default false
     */
    rtl: boolean;
    /**
     * Determines how the focus behaves when the user reaches the end of the
     * composite widget.
     *
     * On one-dimensional composites:
     * - `true` loops from the last item to the first item and vice-versa.
     * - `horizontal` loops only if `orientation` is `horizontal` or not set.
     * - `vertical` loops only if `orientation` is `vertical` or not set.
     * - If `includesBaseElement` is set to `true` (or `activeId` is initially set
     *   to `null`), the composite element will be focused in between the last and
     *   first items.
     *
     * On two-dimensional composites (when using `CompositeRow`):
     * - `true` loops from the last row/column item to the first item in the same
     *   row/column and vice-versa. If it's the last item in the last row, it
     *   moves to the first item in the first row and vice-versa.
     * - `horizontal` loops only from the last row item to the first item in the
     *   same row.
     * - `vertical` loops only from the last column item to the first item in the
     *   column row.
     * - If `includesBaseElement` is set to `true` (or `activeId` is initially set
     *   to `null`), vertical loop will have no effect as moving down from the
     *   last row or up from the first row will focus the composite element.
     * - If `focusWrap` matches the value of `focusLoop`, it'll wrap between the
     *   last item in the last row or column and the first item in the first row
     *   or column and vice-versa.
     * @default false
     */
    focusLoop: boolean | Orientation;
    /**
     * **Works only on two-dimensional composites**. If enabled, moving to the
     * next item from the last one in a row or column will focus the first item in
     * the next row or column and vice-versa.
     * - `true` wraps between rows and columns.
     * - `horizontal` wraps only between rows.
     * - `vertical` wraps only between columns.
     * - If `focusLoop` matches the value of `focusWrap`, it'll wrap between the
     *   last item in the last row or column and the first item in the first row
     *   or column and vice-versa.
     * @default false
     */
    focusWrap: boolean | Orientation;
    /**
     * **Works only on two-dimensional composites**. If enabled, moving up or down
     * when there's no next item or when the next item is disabled will shift to
     * the item right before it.
     * @default false
     */
    focusShift: boolean;
    /**
     * The number of times the `move` function has been called.
     */
    moves: number;
    /**
     * Indicates whether the composite element should be included in the focus
     * order.
     * @default false
     */
    includesBaseElement: boolean;
    /**
     * The current focused item `id`.
     * - `null` focuses the base composite element and users will be able to
     *   navigate out of it using arrow keys.
     * - If `activeId` is initially set to `null`, the `includesBaseElement` prop
     *   will also default to `true`, which means the base composite element
     *   itself will have focus and users will be able to navigate to it using
     *   arrow keys.
     */
    activeId: string | null | undefined;
}
export interface CompositeStoreFunctions<T extends Item = Item> extends CollectionStoreFunctions<T> {
    /**
     * Sets the `baseElement`.
     */
    setBaseElement: SetState<CompositeStoreState<T>["baseElement"]>;
    /**
     * Sets the `activeId` state without moving focus. If you want to move focus,
     * use the `move` function instead.
     * @example
     * // Sets the composite element as the active item
     * store.setActiveId(null);
     * // Sets the item with id "item-1" as the active item
     * store.setActiveId("item-1");
     * // Sets the next item as the active item
     * store.setActiveId(store.next());
     */
    setActiveId: SetState<CompositeStoreState<T>["activeId"]>;
    /**
     * Moves focus to a given item id and sets it as the active item. Passing
     * `null` will focus the composite element itself.
     * @param id The item id to move focus to.
     * @example
     * // Moves focus to the composite element
     * store.move(null);
     * // Moves focus to the item with id "item-1"
     * store.move("item-1");
     * // Moves focus to the next item
     * store.move(store.next());
     */
    move: (id?: string | null) => void;
    /**
     * Returns the id of the next item based on the current `activeId` state.
     * @param skip The number of items to skip. Defaults to 1.
     * @example
     * const nextId = store.next();
     * const nextNextId = store.next(2);
     */
    next: (skip?: number) => string | null | undefined;
    /**
     * Returns the id of the previous item based on the current `activeId` state.
     * @param skip The number of items to skip. Defaults to 1.
     * @example
     * const previousId = store.previous();
     * const previousPreviousId = store.previous(2);
     */
    previous: (skip?: number) => string | null | undefined;
    /**
     * Returns the id of the item above based on the current `activeId` state.
     * @param skip The number of items to skip. Defaults to 1.
     * @example
     * const upId = store.up();
     * const upUpId = store.up(2);
     */
    up: (skip?: number) => string | null | undefined;
    /**
     * Returns the id of the item below based on the current `activeId` state.
     * @param skip The number of items to skip. Defaults to 1.
     * @example
     * const downId = store.down();
     * const downDownId = store.down(2);
     */
    down: (skip?: number) => string | null | undefined;
    /**
     * Returns the id of the first item.
     */
    first: () => string | null | undefined;
    /**
     * Returns the id of the last item.
     */
    last: () => string | null | undefined;
}
export interface CompositeStoreOptions<T extends Item = Item> extends StoreOptions<CompositeStoreState<T>, "virtualFocus" | "orientation" | "rtl" | "focusLoop" | "focusWrap" | "focusShift" | "includesBaseElement" | "activeId">, CollectionStoreOptions<T> {
    /**
     * The composite item id that should be active by default when the composite
     * widget is rendered. If `null`, the composite element itself will have focus
     * and users will be able to navigate to it using arrow keys. If `undefined`,
     * the first enabled item will be focused.
     */
    defaultActiveId?: CompositeStoreState<T>["activeId"];
}
export type CompositeStoreProps<T extends Item = Item> = CompositeStoreOptions<T> & StoreProps<CompositeStoreState<T>>;
export type CompositeStore<T extends Item = Item> = CompositeStoreFunctions<T> & Store<CompositeStoreState<T>>;
export {};
