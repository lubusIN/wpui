"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _DZGTHAPXcjs = require('../__chunks/DZGTHAPX.cjs');



var _MPFAD3UKcjs = require('../__chunks/MPFAD3UK.cjs');
require('../__chunks/Q5EWS32Z.cjs');
require('../__chunks/A764D2YK.cjs');
require('../__chunks/KLZID3QO.cjs');
require('../__chunks/5VOPA6D3.cjs');


var _4ZIMX233cjs = require('../__chunks/4ZIMX233.cjs');
require('../__chunks/OLGMV24U.cjs');
require('../__chunks/3ALHBZ3R.cjs');
require('../__chunks/MNUCM2FP.cjs');
require('../__chunks/TUSNAJ32.cjs');
require('../__chunks/CHVOMF22.cjs');
require('../__chunks/FA3DXDDT.cjs');
require('../__chunks/F4UT5TWU.cjs');
require('../__chunks/ELOQI33M.cjs');
require('../__chunks/6BAHKJ5K.cjs');
require('../__chunks/KJBIRAH5.cjs');
require('../__chunks/HTEAWNBY.cjs');
require('../__chunks/Z3TLXRS7.cjs');
require('../__chunks/X2GXTE3P.cjs');
require('../__chunks/56NPFF7P.cjs');
require('../__chunks/W32FX7DM.cjs');
require('../__chunks/BWQVQDGC.cjs');
require('../__chunks/G6F4DPHM.cjs');
require('../__chunks/PD5YFDLO.cjs');
require('../__chunks/SOPRUU56.cjs');
require('../__chunks/YPXV3X22.cjs');
require('../__chunks/RXCUKHX3.cjs');
require('../__chunks/NS56XHXG.cjs');
require('../__chunks/CQSUIL2D.cjs');
require('../__chunks/N2VCZZLP.cjs');
require('../__chunks/AGPJKWIO.cjs');
require('../__chunks/SZTCN3SG.cjs');
require('../__chunks/W5PBA4D6.cjs');
require('../__chunks/I4JDDV3V.cjs');
require('../__chunks/LHHW5ZQP.cjs');
require('../__chunks/QR3ATHWU.cjs');




var _CWY2PHPRcjs = require('../__chunks/CWY2PHPR.cjs');
require('../__chunks/OVOYNBFC.cjs');
require('../__chunks/MPGRRS75.cjs');




var _5WLTMVVQcjs = require('../__chunks/5WLTMVVQ.cjs');
require('../__chunks/7WUTS26Y.cjs');




var _72I2GWXFcjs = require('../__chunks/72I2GWXF.cjs');

// src/menu/menu.ts
var _react = require('react');
var _focus = require('@ariakit/core/utils/focus');
var useMenu = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      hideOnEscape = true,
      autoFocusOnShow = true,
      hideOnHoverOutside,
      alwaysVisible
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "store",
      "hideOnEscape",
      "autoFocusOnShow",
      "hideOnHoverOutside",
      "alwaysVisible"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const parentMenu = _react.useContext.call(void 0, _MPFAD3UKcjs.MenuContext);
    const parentMenuBar = _react.useContext.call(void 0, _MPFAD3UKcjs.MenuBarContext);
    const hasParentMenu = !!parentMenu;
    const parentIsMenuBar = !!parentMenuBar && !hasParentMenu;
    const onKeyDownProp = props.onKeyDown;
    const hideOnEscapeProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, hideOnEscape);
    const onKeyDown = _5WLTMVVQcjs.useEvent.call(void 0, (event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.key === "Escape") {
        if (!hideOnEscapeProp(event))
          return;
        if (!hasParentMenu) {
          event.stopPropagation();
        }
        return store.hide();
      }
    });
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, props.ref),
      onKeyDown
    });
    const _a2 = _DZGTHAPXcjs.useMenuList.call(void 0, 
      _72I2GWXFcjs.__spreadValues.call(void 0, { store, alwaysVisible }, props)
    ), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = _72I2GWXFcjs.__objRest.call(void 0, _a2, ["aria-labelledby"]);
    props = menuListProps;
    const [initialFocusRef, setInitialFocusRef] = _react.useState.call(void 0, );
    const autoFocusOnShowState = store.useState("autoFocusOnShow");
    const initialFocus = store.useState("initialFocus");
    const baseElement = store.useState("baseElement");
    const items = store.useState("renderedItems");
    _react.useEffect.call(void 0, () => {
      let cleaning = false;
      setInitialFocusRef((prevInitialFocusRef) => {
        var _a3, _b2, _c;
        if (cleaning)
          return;
        if (!autoFocusOnShowState)
          return;
        if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected)
          return prevInitialFocusRef;
        const ref2 = _react.createRef.call(void 0, );
        switch (initialFocus) {
          case "first":
            ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
            break;
          case "last":
            ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
            break;
          default:
            ref2.current = baseElement;
        }
        if (!ref2.current)
          return;
        return ref2;
      });
      return () => {
        cleaning = true;
      };
    }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!props.modal;
    props = _4ZIMX233cjs.useHovercard.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      store,
      alwaysVisible,
      initialFocus: initialFocusRef,
      autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!props.modal
    }, props), {
      hideOnHoverOutside: (event) => {
        if (typeof hideOnHoverOutside === "function") {
          return hideOnHoverOutside(event);
        }
        if (hideOnHoverOutside != null)
          return hideOnHoverOutside;
        if (hasParentMenu) {
          parentMenu.setActiveId(null);
          return true;
        }
        if (!parentIsMenuBar)
          return false;
        const { disclosureElement } = store.getState();
        const disclosure = disclosureElement;
        if (!disclosure)
          return true;
        if (_focus.hasFocusWithin.call(void 0, disclosure))
          return false;
        return true;
      },
      // If it's a submenu, it shouldn't behave like a modal dialog, nor display
      // a backdrop.
      modal: hasParentMenu ? false : props.modal,
      backdrop: hasParentMenu ? false : props.backdrop,
      // If it's a submenu, hide on esc will be handled differently. That is,
      // event.stopPropagation() won't be called, so the parent menus will also
      // be closed.
      hideOnEscape: hasParentMenu ? false : hideOnEscape
    }));
    props = _72I2GWXFcjs.__spreadValues.call(void 0, {
      "aria-labelledby": ariaLabelledBy
    }, props);
    return props;
  }
);
var Menu = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useMenu(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Menu.displayName = "Menu";
}



exports.Menu = Menu; exports.useMenu = useMenu;
