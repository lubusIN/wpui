"use strict";Object.defineProperty(exports, "__esModule", {value: true});








var _RCYVACJOcjs = require('./RCYVACJO.cjs');



var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/utils/store.ts
function getInternal(store, key) {
  const internals = store.__unstableInternals;
  _RCYVACJOcjs.invariant.call(void 0, internals, "Invalid store");
  return internals[key];
}
function createStore(initialState, ...stores) {
  let state = initialState;
  let prevStateBatch = state;
  let lastUpdate = Symbol();
  let initialized = false;
  const updatedKeys = /* @__PURE__ */ new Set();
  const setups = /* @__PURE__ */ new Set();
  const listeners = /* @__PURE__ */ new Set();
  const listenersBatch = /* @__PURE__ */ new Set();
  const disposables = /* @__PURE__ */ new WeakMap();
  const listenerKeys = /* @__PURE__ */ new WeakMap();
  const storeSetup = (callback) => {
    setups.add(callback);
    return () => setups.delete(callback);
  };
  const storeInit = () => {
    if (initialized)
      return _RCYVACJOcjs.noop;
    if (!stores.length)
      return _RCYVACJOcjs.noop;
    initialized = true;
    const desyncs = _RCYVACJOcjs.getKeys.call(void 0, state).map(
      (key) => _RCYVACJOcjs.chain.call(void 0, 
        ...stores.map((store) => {
          var _a;
          const storeState = (_a = store == null ? void 0 : store.getState) == null ? void 0 : _a.call(store);
          if (!storeState)
            return;
          if (!_RCYVACJOcjs.hasOwnProperty.call(void 0, storeState, key))
            return;
          return sync(store, [key], (state2) => setState(key, state2[key]));
        })
      )
    );
    const teardowns = [];
    setups.forEach((setup2) => teardowns.push(setup2()));
    const cleanups = stores.map(init);
    return _RCYVACJOcjs.chain.call(void 0, ...desyncs, ...teardowns, ...cleanups, () => {
      initialized = false;
    });
  };
  const sub = (keys, listener, batch2 = false) => {
    const set = batch2 ? listenersBatch : listeners;
    set.add(listener);
    listenerKeys.set(listener, keys);
    return () => {
      var _a;
      (_a = disposables.get(listener)) == null ? void 0 : _a();
      disposables.delete(listener);
      listenerKeys.delete(listener);
      set.delete(listener);
    };
  };
  const storeSubscribe = (keys, listener) => sub(keys, listener);
  const storeSync = (keys, listener) => {
    disposables.set(listener, listener(state, state));
    return sub(keys, listener);
  };
  const storeBatch = (keys, listener) => {
    disposables.set(listener, listener(state, prevStateBatch));
    return sub(keys, listener, true);
  };
  const storePick = (keys) => createStore(_RCYVACJOcjs.pick.call(void 0, state, keys), finalStore);
  const storeOmit = (keys) => createStore(_RCYVACJOcjs.omit.call(void 0, state, keys), finalStore);
  const getState = () => state;
  const setState = (key, value) => {
    if (!_RCYVACJOcjs.hasOwnProperty.call(void 0, state, key))
      return;
    const nextValue = _RCYVACJOcjs.applyState.call(void 0, value, state[key]);
    if (nextValue === state[key])
      return;
    stores.forEach((store) => {
      var _a;
      (_a = store == null ? void 0 : store.setState) == null ? void 0 : _a.call(store, key, nextValue);
    });
    const prevState = state;
    state = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, state), { [key]: nextValue });
    const thisUpdate = Symbol();
    lastUpdate = thisUpdate;
    updatedKeys.add(key);
    const run = (listener, prev, uKeys) => {
      var _a;
      const keys = listenerKeys.get(listener);
      const updated = (k) => uKeys ? uKeys.has(k) : k === key;
      if (!keys || keys.some(updated)) {
        (_a = disposables.get(listener)) == null ? void 0 : _a();
        disposables.set(listener, listener(state, prev));
      }
    };
    listeners.forEach((listener) => run(listener, prevState));
    queueMicrotask(() => {
      if (lastUpdate !== thisUpdate)
        return;
      const snapshot = state;
      listenersBatch.forEach((listener) => {
        run(listener, prevStateBatch, updatedKeys);
      });
      prevStateBatch = snapshot;
      updatedKeys.clear();
    });
  };
  const finalStore = {
    getState,
    setState,
    __unstableInternals: {
      setup: storeSetup,
      init: storeInit,
      subscribe: storeSubscribe,
      sync: storeSync,
      batch: storeBatch,
      pick: storePick,
      omit: storeOmit
    }
  };
  return finalStore;
}
function setup(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "setup")(...args);
}
function init(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "init")(...args);
}
function subscribe(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "subscribe")(...args);
}
function sync(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "sync")(...args);
}
function batch(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "batch")(...args);
}
function omit2(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "omit")(...args);
}
function pick2(store, ...args) {
  if (!store)
    return;
  return getInternal(store, "pick")(...args);
}
function mergeStore(...stores) {
  const initialState = stores.reduce((state, store2) => {
    var _a;
    const nextState = (_a = store2 == null ? void 0 : store2.getState) == null ? void 0 : _a.call(store2);
    if (!nextState)
      return state;
    return _72I2GWXFcjs.__spreadValues.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, state), nextState);
  }, {});
  const store = createStore(initialState, ...stores);
  return store;
}











exports.createStore = createStore; exports.setup = setup; exports.init = init; exports.subscribe = subscribe; exports.sync = sync; exports.batch = batch; exports.omit = omit2; exports.pick = pick2; exports.mergeStore = mergeStore;
