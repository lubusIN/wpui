import {
  POPOVER_ARROW_PATH
} from "./GM7XQV7F.js";
import {
  PopoverContext
} from "./6GS36SYX.js";
import {
  createComponent,
  createElement,
  createHook
} from "./NQJBHION.js";
import {
  useMergeRefs,
  useSafeLayoutEffect
} from "./J7Q2EO23.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/popover/popover-arrow.tsx
import { useContext, useMemo, useState } from "react";
import { getWindow } from "@ariakit/core/utils/dom";
import { invariant } from "@ariakit/core/utils/misc";
import { jsx, jsxs } from "react/jsx-runtime";
var defaultSize = 30;
var halfDefaultSize = defaultSize / 2;
var rotateMap = {
  top: `rotate(180 ${halfDefaultSize} ${halfDefaultSize})`,
  right: `rotate(-90 ${halfDefaultSize} ${halfDefaultSize})`,
  bottom: `rotate(0 ${halfDefaultSize} ${halfDefaultSize})`,
  left: `rotate(90 ${halfDefaultSize} ${halfDefaultSize})`
};
function useComputedStyle(store) {
  const [style, setStyle] = useState();
  const contentElement = store.useState("contentElement");
  useSafeLayoutEffect(() => {
    if (!contentElement)
      return;
    const win = getWindow(contentElement);
    const computedStyle = win.getComputedStyle(contentElement);
    setStyle(computedStyle);
  }, [contentElement]);
  return style;
}
var usePopoverArrow = createHook(
  (_a) => {
    var _b = _a, { store, size = defaultSize } = _b, props = __objRest(_b, ["store", "size"]);
    const context = useContext(PopoverContext);
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "PopoverArrow must be wrapped in a Popover component"
    );
    const dir = store.useState(
      (state) => state.currentPlacement.split("-")[0]
    );
    const style = useComputedStyle(store);
    const fill = (style == null ? void 0 : style.getPropertyValue("background-color")) || "none";
    const stroke = (style == null ? void 0 : style.getPropertyValue(`border-${dir}-color`)) || "none";
    const borderWidth = (style == null ? void 0 : style.getPropertyValue(`border-${dir}-width`)) || "0px";
    const strokeWidth = parseInt(borderWidth) * 2 * (defaultSize / size);
    const transform = rotateMap[dir];
    const children = useMemo(
      () => /* @__PURE__ */ jsx("svg", { display: "block", viewBox: "0 0 30 30", children: /* @__PURE__ */ jsxs("g", { transform, children: [
        /* @__PURE__ */ jsx("path", { fill: "none", d: POPOVER_ARROW_PATH }),
        /* @__PURE__ */ jsx("path", { stroke: "none", d: POPOVER_ARROW_PATH })
      ] }) }),
      [transform]
    );
    props = __spreadProps(__spreadValues({
      children,
      "aria-hidden": true
    }, props), {
      ref: useMergeRefs(store.setArrowElement, props.ref),
      style: __spreadValues({
        // server side rendering
        position: "absolute",
        fontSize: size,
        width: "1em",
        height: "1em",
        pointerEvents: "none",
        fill,
        stroke,
        strokeWidth
      }, props.style)
    });
    return props;
  }
);
var PopoverArrow = createComponent((props) => {
  const htmlProps = usePopoverArrow(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  PopoverArrow.displayName = "PopoverArrow";
}

export {
  usePopoverArrow,
  PopoverArrow
};
