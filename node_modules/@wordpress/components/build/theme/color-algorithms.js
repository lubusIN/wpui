"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkContrasts = checkContrasts;
exports.generateShades = generateShades;
exports.generateThemeVariables = generateThemeVariables;
var _colord = require("colord");
var _a11y = _interopRequireDefault(require("colord/plugins/a11y"));
var _names = _interopRequireDefault(require("colord/plugins/names"));
var _warning = _interopRequireDefault(require("@wordpress/warning"));
var _utils = require("../utils");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

(0, _colord.extend)([_names.default, _a11y.default]);
function generateThemeVariables(inputs) {
  validateInputs(inputs);
  const generatedColors = {
    ...generateAccentDependentColors(inputs.accent),
    ...generateBackgroundDependentColors(inputs.background)
  };
  warnContrastIssues(checkContrasts(inputs, generatedColors));
  return {
    colors: generatedColors
  };
}
function validateInputs(inputs) {
  for (const [key, value] of Object.entries(inputs)) {
    if (typeof value !== 'undefined' && !(0, _colord.colord)(value).isValid()) {
      typeof SCRIPT_DEBUG !== "undefined" && SCRIPT_DEBUG === true ? (0, _warning.default)(`wp.components.Theme: "${value}" is not a valid color value for the '${key}' prop.`) : void 0;
    }
  }
}
function checkContrasts(inputs, outputs) {
  const background = inputs.background || _utils.COLORS.white;
  const accent = inputs.accent || '#3858e9';
  const foreground = outputs.foreground || _utils.COLORS.gray[900];
  const gray = outputs.gray || _utils.COLORS.gray;
  return {
    accent: (0, _colord.colord)(background).isReadable(accent) ? undefined : `The background color ("${background}") does not have sufficient contrast against the accent color ("${accent}").`,
    foreground: (0, _colord.colord)(background).isReadable(foreground) ? undefined : `The background color provided ("${background}") does not have sufficient contrast against the standard foreground colors.`,
    grays: (0, _colord.colord)(background).contrast(gray[600]) >= 3 && (0, _colord.colord)(background).contrast(gray[700]) >= 4.5 ? undefined : `The background color provided ("${background}") cannot generate a set of grayscale foreground colors with sufficient contrast. Try adjusting the color to be lighter or darker.`
  };
}
function warnContrastIssues(issues) {
  for (const error of Object.values(issues)) {
    if (error) {
      typeof SCRIPT_DEBUG !== "undefined" && SCRIPT_DEBUG === true ? (0, _warning.default)('wp.components.Theme: ' + error) : void 0;
    }
  }
}
function generateAccentDependentColors(accent) {
  if (!accent) return {};
  return {
    accent,
    accentDarker10: (0, _colord.colord)(accent).darken(0.1).toHex(),
    accentDarker20: (0, _colord.colord)(accent).darken(0.2).toHex(),
    accentInverted: getForegroundForColor(accent)
  };
}
function generateBackgroundDependentColors(background) {
  if (!background) return {};
  const foreground = getForegroundForColor(background);
  return {
    background,
    foreground,
    foregroundInverted: getForegroundForColor(foreground),
    gray: generateShades(background, foreground)
  };
}
function getForegroundForColor(color) {
  return (0, _colord.colord)(color).isDark() ? _utils.COLORS.white : _utils.COLORS.gray[900];
}
function generateShades(background, foreground) {
  // How much darkness you need to add to #fff to get the COLORS.gray[n] color
  const SHADES = {
    100: 0.06,
    200: 0.121,
    300: 0.132,
    400: 0.2,
    600: 0.42,
    700: 0.543,
    800: 0.821
  };

  // Darkness of COLORS.gray[ 900 ], relative to #fff
  const limit = 0.884;
  const direction = (0, _colord.colord)(background).isDark() ? 'lighten' : 'darken';

  // Lightness delta between the background and foreground colors
  const range = Math.abs((0, _colord.colord)(background).toHsl().l - (0, _colord.colord)(foreground).toHsl().l) / 100;
  const result = {};
  Object.entries(SHADES).forEach(([key, value]) => {
    result[parseInt(key)] = (0, _colord.colord)(background)[direction](value / limit * range).toHex();
  });
  return result;
}
//# sourceMappingURL=color-algorithms.js.map