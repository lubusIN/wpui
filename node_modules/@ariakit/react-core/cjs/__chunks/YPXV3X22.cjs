"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _RXCUKHX3cjs = require('./RXCUKHX3.cjs');


var _NS56XHXGcjs = require('./NS56XHXG.cjs');




var _CWY2PHPRcjs = require('./CWY2PHPR.cjs');




var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');


var _7WUTS26Ycjs = require('./7WUTS26Y.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/portal/portal.tsx
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');
var _events = require('@ariakit/core/utils/events');





var _focus = require('@ariakit/core/utils/focus');
var _reactdom = require('react-dom');
var _jsxruntime = require('react/jsx-runtime');
function getRootElement(element) {
  return _dom.getDocument.call(void 0, element).body;
}
function getPortalElement(element, portalElement) {
  if (!portalElement) {
    return _dom.getDocument.call(void 0, element).createElement("div");
  }
  if (typeof portalElement === "function") {
    return portalElement(element);
  }
  return portalElement;
}
function getRandomId(prefix = "id") {
  return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).substr(2, 6)}`;
}
function queueFocus(element) {
  queueMicrotask(() => {
    element == null ? void 0 : element.focus();
  });
}
var usePortal = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, { preserveTabOrder, portalElement, portalRef, portal = true } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, ["preserveTabOrder", "portalElement", "portalRef", "portal"]);
    const ref = _react.useRef.call(void 0, null);
    const refProp = _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, props.ref);
    const context = _react.useContext.call(void 0, _NS56XHXGcjs.PortalContext);
    const [portalNode, setPortalNode] = _react.useState.call(void 0, null);
    const outerBeforeRef = _react.useRef.call(void 0, null);
    const innerBeforeRef = _react.useRef.call(void 0, null);
    const innerAfterRef = _react.useRef.call(void 0, null);
    const outerAfterRef = _react.useRef.call(void 0, null);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      const element = ref.current;
      if (!element || !portal) {
        setPortalNode(null);
        return;
      }
      const portalEl = getPortalElement(element, portalElement);
      if (!portalEl) {
        setPortalNode(null);
        return;
      }
      const isPortalInDocument = portalEl.isConnected;
      if (!isPortalInDocument) {
        const rootElement = context || getRootElement(element);
        rootElement.appendChild(portalEl);
      }
      if (!portalEl.id) {
        portalEl.id = element.id ? `portal/${element.id}` : getRandomId();
      }
      setPortalNode(portalEl);
      _7WUTS26Ycjs.setRef.call(void 0, portalRef, portalEl);
      if (isPortalInDocument)
        return;
      return () => {
        portalEl.remove();
        _7WUTS26Ycjs.setRef.call(void 0, portalRef, null);
      };
    }, [portal, portalElement, context, portalRef]);
    _react.useEffect.call(void 0, () => {
      if (!portalNode)
        return;
      if (!preserveTabOrder)
        return;
      let raf = 0;
      const onFocus = (event) => {
        if (!_events.isFocusEventOutside.call(void 0, event))
          return;
        const focusing = event.type === "focusin";
        if (focusing)
          return _focus.restoreFocusIn.call(void 0, portalNode);
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          _focus.disableFocusIn.call(void 0, portalNode, true);
        });
      };
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder]);
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        element = // While the portal node is not in the DOM, we need to pass the
        // current context to the portal context, otherwise it's going to
        // reset to the body element on nested portals.
        /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _NS56XHXGcjs.PortalContext.Provider, { value: portalNode || context, children: element });
        if (!portal)
          return element;
        if (!portalNode) {
          return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            "span",
            {
              ref: refProp,
              id: props.id,
              style: { position: "fixed" },
              hidden: true
            }
          );
        }
        element = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _RXCUKHX3cjs.FocusTrap,
            {
              ref: innerBeforeRef,
              className: "__focus-trap-inner-before",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getNextTabbable.call(void 0, ));
                } else {
                  queueFocus(outerBeforeRef.current);
                }
              }
            }
          ),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _RXCUKHX3cjs.FocusTrap,
            {
              ref: innerAfterRef,
              className: "__focus-trap-inner-after",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                } else {
                  queueFocus(outerAfterRef.current);
                }
              }
            }
          )
        ] });
        if (portalNode) {
          element = _reactdom.createPortal.call(void 0, element, portalNode);
        }
        element = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _RXCUKHX3cjs.FocusTrap,
            {
              ref: outerBeforeRef,
              className: "__focus-trap-outer-before",
              onFocus: (event) => {
                const fromOuter = event.relatedTarget === outerAfterRef.current;
                if (!fromOuter && _events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(innerBeforeRef.current);
                } else {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                }
              }
            }
          ),
          preserveTabOrder && // We're using position: fixed here so that the browser doesn't
          // add margin to the element when setting gap on a parent element.
          /* @__PURE__ */ _jsxruntime.jsx.call(void 0, "span", { "aria-owns": portalNode == null ? void 0 : portalNode.id, style: { position: "fixed" } }),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _RXCUKHX3cjs.FocusTrap,
            {
              ref: outerAfterRef,
              className: "__focus-trap-outer-after",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(innerAfterRef.current);
                } else {
                  const nextTabbable = _focus.getNextTabbable.call(void 0, );
                  if (nextTabbable === innerBeforeRef.current) {
                    requestAnimationFrame(() => {
                      var _a2;
                      return (_a2 = _focus.getNextTabbable.call(void 0, )) == null ? void 0 : _a2.focus();
                    });
                    return;
                  }
                  queueFocus(nextTabbable);
                }
              }
            }
          )
        ] });
        return element;
      },
      [portalNode, context, portal, props.id, preserveTabOrder]
    );
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), {
      ref: refProp
    });
    return props;
  }
);
var Portal = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  const htmlProps = usePortal(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}




exports.usePortal = usePortal; exports.Portal = Portal;
