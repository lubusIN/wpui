"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metrics = void 0;
class Metrics {
    page;
    constructor(page) {
        this.page = page;
        this.page = page;
    }
    /**
     * Returns durations from the Server-Timing header.
     *
     * @param fields Optional fields to filter.
     */
    async getServerTiming(fields = []) {
        return this.page.evaluate((f) => performance.getEntriesByType('navigation')[0].serverTiming.reduce((acc, entry) => {
            if (f.length === 0 || f.includes(entry.name)) {
                acc[entry.name] = entry.duration;
            }
            return acc;
        }, {}), fields);
    }
    /**
     * Returns time to first byte (TTFB) using the Navigation Timing API.
     *
     * @see https://web.dev/ttfb/#measure-ttfb-in-javascript
     *
     * @return {Promise<number>} TTFB value.
     */
    async getTimeToFirstByte() {
        return this.page.evaluate(() => {
            const { responseStart, startTime } = performance.getEntriesByType('navigation')[0];
            return responseStart - startTime;
        });
    }
    /**
     * Returns the Largest Contentful Paint (LCP) value using the dedicated API.
     *
     * @see https://w3c.github.io/largest-contentful-paint/
     * @see https://web.dev/lcp/#measure-lcp-in-javascript
     *
     * @return {Promise<number>} LCP value.
     */
    async getLargestContentfulPaint() {
        return this.page.evaluate(() => new Promise((resolve) => {
            new PerformanceObserver((entryList) => {
                const entries = entryList.getEntries();
                // The last entry is the largest contentful paint.
                const largestPaintEntry = entries.at(-1);
                resolve(largestPaintEntry?.startTime || 0);
            }).observe({
                type: 'largest-contentful-paint',
                buffered: true,
            });
        }));
    }
    /**
     * Returns the Cumulative Layout Shift (CLS) value using the dedicated API.
     *
     * @see https://github.com/WICG/layout-instability
     * @see https://web.dev/cls/#measure-layout-shifts-in-javascript
     *
     * @return {Promise<number>} CLS value.
     */
    async getCumulativeLayoutShift() {
        return this.page.evaluate(() => new Promise((resolve) => {
            let CLS = 0;
            new PerformanceObserver((l) => {
                const entries = l.getEntries();
                entries.forEach((entry) => {
                    if (!entry.hadRecentInput) {
                        CLS += entry.value;
                    }
                });
                resolve(CLS);
            }).observe({
                type: 'layout-shift',
                buffered: true,
            });
        }));
    }
}
exports.Metrics = Metrics;
//# sourceMappingURL=index.js.map