"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Option = Option;
var _element = require("@wordpress/element");
var _classnames = _interopRequireDefault(require("classnames"));
var _compose = require("@wordpress/compose");
var _icons = require("@wordpress/icons");
var _circularOptionPickerContext = require("./circular-option-picker-context");
var _button = _interopRequireDefault(require("../button"));
var _composite = require("../composite");
var _tooltip = _interopRequireDefault(require("../tooltip"));
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const hasSelectedOption = new Map();
function UnforwardedOptionAsButton(props, forwardedRef) {
  return (0, _element.createElement)(_button.default, {
    ...props,
    ref: forwardedRef
  });
}
const OptionAsButton = (0, _element.forwardRef)(UnforwardedOptionAsButton);
function UnforwardedOptionAsOption(props, forwardedRef) {
  const {
    id,
    className,
    isSelected,
    context,
    ...additionalProps
  } = props;
  const {
    isComposite,
    ..._compositeState
  } = context;
  const compositeState = _compositeState;
  const {
    baseId,
    currentId,
    setCurrentId
  } = compositeState;
  (0, _element.useEffect)(() => {
    // If we call `setCurrentId` here, it doesn't update for other
    // Option renders in the same pass. So we have to store our own
    // map to make sure that we only set the first selected option.
    // We still need to check `currentId` because the control will
    // update this as the user moves around, and that state should
    // be maintained as the group gains and loses focus.
    if (isSelected && !currentId && !hasSelectedOption.get(baseId)) {
      hasSelectedOption.set(baseId, true);
      setCurrentId(id);
    }
  }, [baseId, currentId, id, isSelected, setCurrentId]);
  return (0, _element.createElement)(_composite.CompositeItem, {
    ...additionalProps,
    ...compositeState,
    as: _button.default,
    id: id
    // Ideally we'd let the underlying `Button` component
    // handle this by passing `isPressed` as a prop.
    // Unfortunately doing so also sets `aria-pressed` as
    // an attribute on the element, which is incompatible
    // with `role="option"`, and there is no way at this
    // point to override that behaviour.
    ,
    className: (0, _classnames.default)(className, {
      'is-pressed': isSelected
    }),
    role: "option",
    "aria-selected": !!isSelected,
    ref: forwardedRef
  });
}
const OptionAsOption = (0, _element.forwardRef)(UnforwardedOptionAsOption);
function Option({
  className,
  isSelected,
  selectedIconProps = {},
  tooltipText,
  ...additionalProps
}) {
  const compositeContext = (0, _element.useContext)(_circularOptionPickerContext.CircularOptionPickerContext);
  const {
    isComposite,
    baseId
  } = compositeContext;
  const id = (0, _compose.useInstanceId)(Option, baseId || 'components-circular-option-picker__option');
  const commonProps = {
    id,
    className: 'components-circular-option-picker__option',
    ...additionalProps
  };
  const optionControl = isComposite ? (0, _element.createElement)(OptionAsOption, {
    ...commonProps,
    context: compositeContext,
    isSelected: isSelected
  }) : (0, _element.createElement)(OptionAsButton, {
    ...commonProps,
    isPressed: isSelected
  });
  return (0, _element.createElement)("div", {
    className: (0, _classnames.default)(className, 'components-circular-option-picker__option-wrapper')
  }, tooltipText ? (0, _element.createElement)(_tooltip.default, {
    text: tooltipText
  }, optionControl) : optionControl, isSelected && (0, _element.createElement)(_icons.Icon, {
    icon: _icons.check,
    ...selectedIconProps
  }));
}
//# sourceMappingURL=circular-option-picker-option.js.map