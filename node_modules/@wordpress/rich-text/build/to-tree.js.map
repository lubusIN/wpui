{"version":3,"names":["_getActiveFormats","require","_getFormatType","_specialCharacters","restoreOnAttributes","attributes","isEditableTree","newAttributes","key","newKey","startsWith","slice","length","fromFormat","type","tagName","unregisteredAttributes","object","boundaryClass","formatType","getFormatType","elementAttributes","name","className","class","contentEditable","contenteditable","isEqualUntil","a","b","index","toTree","value","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","formats","replacements","text","start","end","formatsLength","tree","activeFormats","getActiveFormats","deepestActiveFormat","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","characterFormats","pointer","forEach","format","formatIndex","parent","newNode","OBJECT_REPLACEMENT_CHARACTER","replacement","innerHTML","html","decodeURIComponent","undefined","ZWNBSP","style"],"sources":["@wordpress/rich-text/src/to-tree.js"],"sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"],"mappings":"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"}