"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUNCATE_TYPE = exports.TRUNCATE_ELLIPSIS = exports.TRUNCATE_DEFAULT_PROPS = void 0;
exports.truncateContent = truncateContent;
exports.truncateMiddle = truncateMiddle;
var _values = require("../utils/values");
/**
 * Internal dependencies
 */

const TRUNCATE_ELLIPSIS = 'â€¦';
exports.TRUNCATE_ELLIPSIS = TRUNCATE_ELLIPSIS;
const TRUNCATE_TYPE = {
  auto: 'auto',
  head: 'head',
  middle: 'middle',
  tail: 'tail',
  none: 'none'
};
exports.TRUNCATE_TYPE = TRUNCATE_TYPE;
const TRUNCATE_DEFAULT_PROPS = {
  ellipsis: TRUNCATE_ELLIPSIS,
  ellipsizeMode: TRUNCATE_TYPE.auto,
  limit: 0,
  numberOfLines: 0
};

// Source
// https://github.com/kahwee/truncate-middle
exports.TRUNCATE_DEFAULT_PROPS = TRUNCATE_DEFAULT_PROPS;
function truncateMiddle(word, headLength, tailLength, ellipsis) {
  if (typeof word !== 'string') {
    return '';
  }
  const wordLength = word.length;
  // Setting default values
  // eslint-disable-next-line no-bitwise
  const frontLength = ~~headLength; // Will cast to integer
  // eslint-disable-next-line no-bitwise
  const backLength = ~~tailLength;
  /* istanbul ignore next */
  const truncateStr = (0, _values.isValueDefined)(ellipsis) ? ellipsis : TRUNCATE_ELLIPSIS;
  if (frontLength === 0 && backLength === 0 || frontLength >= wordLength || backLength >= wordLength || frontLength + backLength >= wordLength) {
    return word;
  } else if (backLength === 0) {
    return word.slice(0, frontLength) + truncateStr;
  }
  return word.slice(0, frontLength) + truncateStr + word.slice(wordLength - backLength);
}
function truncateContent(words = '', props) {
  const mergedProps = {
    ...TRUNCATE_DEFAULT_PROPS,
    ...props
  };
  const {
    ellipsis,
    ellipsizeMode,
    limit
  } = mergedProps;
  if (ellipsizeMode === TRUNCATE_TYPE.none) {
    return words;
  }
  let truncateHead;
  let truncateTail;
  switch (ellipsizeMode) {
    case TRUNCATE_TYPE.head:
      truncateHead = 0;
      truncateTail = limit;
      break;
    case TRUNCATE_TYPE.middle:
      truncateHead = Math.floor(limit / 2);
      truncateTail = Math.floor(limit / 2);
      break;
    default:
      truncateHead = limit;
      truncateTail = 0;
  }
  const truncatedContent = ellipsizeMode !== TRUNCATE_TYPE.auto ? truncateMiddle(words, truncateHead, truncateTail, ellipsis) : words;
  return truncatedContent;
}
//# sourceMappingURL=utils.js.map