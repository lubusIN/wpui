"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Fill;
var _element = require("@wordpress/element");
var _useSlot = _interopRequireDefault(require("./use-slot"));
var _styleProvider = _interopRequireDefault(require("../../style-provider"));
// @ts-nocheck
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useForceUpdate() {
  const [, setState] = (0, _element.useState)({});
  const mounted = (0, _element.useRef)(true);
  (0, _element.useEffect)(() => {
    mounted.current = true;
    return () => {
      mounted.current = false;
    };
  }, []);
  return () => {
    if (mounted.current) {
      setState({});
    }
  };
}
function Fill({
  name,
  children
}) {
  const {
    registerFill,
    unregisterFill,
    ...slot
  } = (0, _useSlot.default)(name);
  const rerender = useForceUpdate();
  const ref = (0, _element.useRef)({
    rerender
  });
  (0, _element.useEffect)(() => {
    // We register fills so we can keep track of their existence.
    // Some Slot implementations need to know if there're already fills
    // registered so they can choose to render themselves or not.
    registerFill(ref);
    return () => {
      unregisterFill(ref);
    };
  }, [registerFill, unregisterFill]);
  if (!slot.ref || !slot.ref.current) {
    return null;
  }
  if (typeof children === 'function') {
    children = children(slot.fillProps);
  }

  // When using a `Fill`, the `children` will be rendered in the document of the
  // `Slot`. This means that we need to wrap the `children` in a `StyleProvider`
  // to make sure we're referencing the right document/iframe (instead of the
  // context of the `Fill`'s parent).
  const wrappedChildren = (0, _element.createElement)(_styleProvider.default, {
    document: slot.ref.current.ownerDocument
  }, children);
  return (0, _element.createPortal)(wrappedChildren, slot.ref.current);
}
//# sourceMappingURL=fill.js.map