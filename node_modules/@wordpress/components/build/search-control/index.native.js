"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _element = require("@wordpress/element");
var _reactNative = require("react-native");
var _i18n = require("@wordpress/i18n");
var _components = require("@wordpress/components");
var _icons = require("@wordpress/icons");
var _style = _interopRequireDefault(require("./style.scss"));
var _platformStyle = _interopRequireDefault(require("./platform-style.scss"));
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

// Merge platform specific styles with the default styles.
const baseStyles = {
  ..._style.default
};
for (const selector in _platformStyle.default) {
  baseStyles[selector] = {
    ...baseStyles[selector],
    ..._platformStyle.default[selector]
  };
}
function selectModifiedStyles(styles, modifier) {
  const modifierMatcher = new RegExp(`--${modifier}$`);
  const modifierSelectors = Object.keys(styles).filter(selector => selector.match(modifierMatcher));
  return modifierSelectors.reduce((modifiedStyles, modifierSelector) => {
    const blockElementSelector = modifierSelector.split('--')[0];
    modifiedStyles[blockElementSelector] = styles[modifierSelector];
    return modifiedStyles;
  }, {});
}
function mergeStyles(styles, updateStyles, selectors) {
  selectors.forEach(selector => {
    styles[selector] = {
      ...styles[selector],
      ...updateStyles[selector]
    };
  });
  return styles;
}
function SearchControl({
  value,
  onChange,
  placeholder = (0, _i18n.__)('Search blocks')
}) {
  const [isActive, setIsActive] = (0, _element.useState)(false);
  const [currentStyles, setCurrentStyles] = (0, _element.useState)(baseStyles);
  const isDark = (0, _reactNative.useColorScheme)() === 'dark';
  const inputRef = (0, _element.useRef)();
  const onCancelTimer = (0, _element.useRef)();
  const isIOS = _reactNative.Platform.OS === 'ios';
  const darkStyles = (0, _element.useMemo)(() => {
    return selectModifiedStyles(baseStyles, 'dark');
  }, []);
  const activeStyles = (0, _element.useMemo)(() => {
    return selectModifiedStyles(baseStyles, 'active');
  }, []);
  const activeDarkStyles = (0, _element.useMemo)(() => {
    return selectModifiedStyles(baseStyles, 'active-dark');
  }, []);
  (0, _element.useEffect)(() => {
    let futureStyles = {
      ...baseStyles
    };
    function mergeFutureStyles(modifiedStyles, shouldUseConditions) {
      const shouldUseModified = shouldUseConditions.every(should => should);
      const updatedStyles = shouldUseModified ? modifiedStyles : futureStyles;
      const selectors = Object.keys(modifiedStyles);
      futureStyles = mergeStyles(futureStyles, updatedStyles, selectors);
    }
    mergeFutureStyles(activeStyles, [isActive]);
    mergeFutureStyles(darkStyles, [isDark]);
    mergeFutureStyles(activeDarkStyles, [isActive, isDark]);
    setCurrentStyles(futureStyles);
    // Disable reason: deferring this refactor to the native team.
    // see https://github.com/WordPress/gutenberg/pull/41166
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isActive, isDark]);
  const clearInput = (0, _element.useCallback)(() => {
    onChange('');
  }, [onChange]);
  const onPress = (0, _element.useCallback)(() => {
    setIsActive(true);
    inputRef.current?.focus();
  }, []);
  const onFocus = (0, _element.useCallback)(() => {
    setIsActive(true);
  }, []);
  const onCancel = (0, _element.useCallback)(() => {
    clearTimeout(onCancelTimer.current);
    onCancelTimer.current = setTimeout(() => {
      inputRef.current?.blur();
      clearInput();
      setIsActive(false);
    }, 0);
  }, [clearInput]);
  const onKeyboardDidHide = (0, _element.useCallback)(() => {
    if (!isIOS) {
      onCancel();
    }
  }, [isIOS, onCancel]);
  (0, _element.useEffect)(() => {
    const keyboardHideSubscription = _reactNative.Keyboard.addListener('keyboardDidHide', onKeyboardDidHide);
    return () => {
      clearTimeout(onCancelTimer.current);
      keyboardHideSubscription.remove();
    };
  }, [onKeyboardDidHide]);
  const {
    'search-control__container': containerStyle,
    'search-control__inner-container': innerContainerStyle,
    'search-control__input-container': inputContainerStyle,
    'search-control__form-input': formInputStyle,
    'search-control__form-input-placeholder': placeholderStyle,
    'search-control__input-button': inputButtonStyle,
    'search-control__input-button-left': inputButtonLeftStyle,
    'search-control__input-button-right': inputButtonRightStyle,
    'search-control__cancel-button': cancelButtonStyle,
    'search-control__cancel-button-text': cancelButtonTextStyle,
    'search-control__icon': iconStyle,
    'search-control__right-icon': rightIconStyle
  } = currentStyles;
  function renderLeftButton() {
    const button = !isIOS && isActive ? (0, _element.createElement)(_components.Button, {
      label: (0, _i18n.__)('Cancel search'),
      icon: _icons.arrowLeft,
      onClick: onCancel,
      style: iconStyle
    }) : (0, _element.createElement)(_icons.Icon, {
      icon: _components.Gridicons.search,
      fill: iconStyle?.color
    });
    return (0, _element.createElement)(_reactNative.View, {
      style: [inputButtonStyle, inputButtonLeftStyle]
    }, button);
  }
  function renderRightButton() {
    let button;

    // Add a View element to properly center the input placeholder via flexbox.
    if (isIOS && !isActive) {
      button = (0, _element.createElement)(_reactNative.View, null);
    }
    if (!!value) {
      button = (0, _element.createElement)(_components.Button, {
        label: (0, _i18n.__)('Clear search'),
        icon: isIOS ? _icons.cancelCircleFilled : _icons.close,
        onClick: clearInput,
        style: [iconStyle, rightIconStyle]
      });
    }
    return (0, _element.createElement)(_reactNative.View, {
      style: [inputButtonStyle, inputButtonRightStyle]
    }, button);
  }
  function renderCancel() {
    if (!isIOS) {
      return null;
    }
    return (0, _element.createElement)(_reactNative.View, {
      style: cancelButtonStyle
    }, (0, _element.createElement)(_reactNative.Text, {
      onPress: onCancel,
      style: cancelButtonTextStyle,
      accessible: true,
      accessibilityRole: 'button',
      accessibilityLabel: (0, _i18n.__)('Cancel search'),
      accessibilityHint: (0, _i18n.__)('Cancel search')
    }, (0, _i18n.__)('Cancel')));
  }
  return (0, _element.createElement)(_reactNative.TouchableOpacity, {
    style: containerStyle,
    onPress: onPress,
    activeOpacity: 1
  }, (0, _element.createElement)(_reactNative.View, {
    style: innerContainerStyle
  }, (0, _element.createElement)(_reactNative.View, {
    style: inputContainerStyle
  }, renderLeftButton(), (0, _element.createElement)(_reactNative.TextInput, {
    ref: inputRef,
    style: formInputStyle,
    placeholderTextColor: placeholderStyle?.color,
    onChangeText: onChange,
    onFocus: onFocus,
    value: value,
    placeholder: placeholder
  }), renderRightButton()), isActive && renderCancel()));
}
var _default = SearchControl;
exports.default = _default;
//# sourceMappingURL=index.native.js.map