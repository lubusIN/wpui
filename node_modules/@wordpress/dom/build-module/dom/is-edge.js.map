{"version":3,"names":["isRTL","getRangeHeight","getRectangleFromRange","isSelectionForward","hiddenCaretRangeFromPoint","assertIsDefined","isInputOrTextArea","scrollIfNoRange","isEdge","container","isReverse","onlyVertical","selectionStart","selectionEnd","value","length","isContentEditable","ownerDocument","defaultView","selection","getSelection","rangeCount","range","getRangeAt","collapsedRange","cloneRange","isForward","isCollapsed","collapse","collapsedRangeRect","rangeRect","rangeHeight","height","isReverseDir","containerRect","getBoundingClientRect","x","left","right","y","top","bottom","testRange","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","Math","abs","hasHorizontalDiff"],"sources":["@wordpress/dom/src/dom/is-edge.js"],"sourcesContent":["/**\n * Internal dependencies\n */\nimport isRTL from './is-rtl';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\nimport { scrollIfNoRange } from './scroll-if-no-range';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {HTMLElement} container            Focusable element.\n * @param {boolean}     isReverse            Set to true to check left, false to check right.\n * @param {boolean}     [onlyVertical=false] Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical = false ) {\n\tif (\n\t\tisInputOrTextArea( container ) &&\n\t\ttypeof container.selectionStart === 'number'\n\t) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! ( /** @type {HTMLElement} */ ( container ).isContentEditable ) ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection || ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tconst rangeHeight = getRangeHeight( range );\n\tif (\n\t\t! isCollapsed &&\n\t\trangeHeight &&\n\t\trangeHeight > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = scrollIfNoRange( container, isReverse, () =>\n\t\thiddenCaretRangeFromPoint( ownerDocument, x, y, container )\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n"],"mappings":"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"}