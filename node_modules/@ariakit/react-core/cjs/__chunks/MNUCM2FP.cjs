"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _TUSNAJ32cjs = require('./TUSNAJ32.cjs');


var _CHVOMF22cjs = require('./CHVOMF22.cjs');


var _FA3DXDDTcjs = require('./FA3DXDDT.cjs');


var _F4UT5TWUcjs = require('./F4UT5TWU.cjs');


var _6BAHKJ5Kcjs = require('./6BAHKJ5K.cjs');


var _KJBIRAH5cjs = require('./KJBIRAH5.cjs');



var _HTEAWNBYcjs = require('./HTEAWNBY.cjs');


var _W32FX7DMcjs = require('./W32FX7DM.cjs');


var _G6F4DPHMcjs = require('./G6F4DPHM.cjs');


var _SOPRUU56cjs = require('./SOPRUU56.cjs');


var _YPXV3X22cjs = require('./YPXV3X22.cjs');




var _N2VCZZLPcjs = require('./N2VCZZLP.cjs');



var _SZTCN3SGcjs = require('./SZTCN3SG.cjs');


var _I4JDDV3Vcjs = require('./I4JDDV3V.cjs');




var _CWY2PHPRcjs = require('./CWY2PHPR.cjs');








var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/dialog/dialog.tsx
var _react = require('react');






var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');




var _focus = require('@ariakit/core/utils/focus');
var _misc = require('@ariakit/core/utils/misc');
var _platform = require('@ariakit/core/utils/platform');
var _jsxruntime = require('react/jsx-runtime');
var isSafariBrowser = _platform.isSafari.call(void 0, );
function isAlreadyFocusingAnotherElement(dialog) {
  const activeElement = _dom.getActiveElement.call(void 0, );
  if (!activeElement)
    return false;
  if (dialog && _dom.contains.call(void 0, dialog, activeElement))
    return false;
  if (_focus.isFocusable.call(void 0, activeElement))
    return true;
  return false;
}
function getElementFromProp(prop, focusable = false) {
  if (!prop)
    return null;
  const element = "current" in prop ? prop.current : prop;
  if (!element)
    return null;
  if (focusable)
    return _focus.isFocusable.call(void 0, element) ? element : null;
  return element;
}
var useDialog = _CWY2PHPRcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      modal = true,
      portal = !!modal,
      backdrop = !!modal,
      backdropProps,
      hideOnEscape = true,
      hideOnInteractOutside = true,
      getPersistentElements,
      preventBodyScroll = !!modal,
      autoFocusOnShow = true,
      autoFocusOnHide = true,
      initialFocus,
      finalFocus
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "store",
      "focusable",
      "modal",
      "portal",
      "backdrop",
      "backdropProps",
      "hideOnEscape",
      "hideOnInteractOutside",
      "getPersistentElements",
      "preventBodyScroll",
      "autoFocusOnShow",
      "autoFocusOnHide",
      "initialFocus",
      "finalFocus"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const { portalRef, domReady } = _5WLTMVVQcjs.usePortalRef.call(void 0, portal, props.portalRef);
    const preserveTabOrderProp = props.preserveTabOrder;
    const preserveTabOrder = store.useState(
      (state) => preserveTabOrderProp && !modal && state.mounted
    );
    const id = _5WLTMVVQcjs.useId.call(void 0, props.id);
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const contentElement = store.useState("contentElement");
    const hidden = _SZTCN3SGcjs.isHidden.call(void 0, mounted, props.hidden, props.alwaysVisible);
    _F4UT5TWUcjs.usePreventBodyScroll.call(void 0, contentElement, id, preventBodyScroll && !hidden);
    _KJBIRAH5cjs.useHideOnInteractOutside.call(void 0, store, hideOnInteractOutside, domReady);
    const { wrapElement, nestedDialogs } = _6BAHKJ5Kcjs.useNestedDialogs.call(void 0, store);
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, props, wrapElement, [wrapElement]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!open)
        return;
      const dialog = ref.current;
      const activeElement = _dom.getActiveElement.call(void 0, dialog, true);
      if (!activeElement)
        return;
      if (activeElement.tagName === "BODY")
        return;
      if (dialog && _dom.contains.call(void 0, dialog, activeElement))
        return;
      store.setDisclosureElement(activeElement);
    }, [open, store]);
    if (isSafariBrowser) {
      _react.useEffect.call(void 0, () => {
        if (!mounted)
          return;
        const { disclosureElement } = store.getState();
        if (!disclosureElement)
          return;
        if (!_dom.isButton.call(void 0, disclosureElement))
          return;
        const onMouseDown = () => {
          let receivedFocus = false;
          const onFocus = () => {
            receivedFocus = true;
          };
          const options = { capture: true, once: true };
          disclosureElement.addEventListener("focusin", onFocus, options);
          _events.queueBeforeEvent.call(void 0, disclosureElement, "mouseup", () => {
            disclosureElement.removeEventListener("focusin", onFocus, true);
            if (receivedFocus)
              return;
            _focus.focusIfNeeded.call(void 0, disclosureElement);
          });
        };
        disclosureElement.addEventListener("mousedown", onMouseDown);
        return () => {
          disclosureElement.removeEventListener("mousedown", onMouseDown);
        };
      }, [mounted, store]);
    }
    const shouldDisableAccessibilityTree = modal || // Usually, we only want to disable the accessibility tree outside if the
    // dialog is a modal. But the Portal component can't preserve the tab
    // order on Safari/VoiceOver. By allowing only the dialog/portal to be
    // accessible, we provide a similar tab order flow. We don't need to
    // disable pointer events because it's just for screen readers.
    portal && preserveTabOrder && _platform.isSafari.call(void 0, );
    _react.useEffect.call(void 0, () => {
      if (!mounted)
        return;
      if (!domReady)
        return;
      const dialog = ref.current;
      if (!dialog)
        return;
      if (!shouldDisableAccessibilityTree)
        return;
      const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
      if (existingDismiss)
        return;
      return _W32FX7DMcjs.prependHiddenDismiss.call(void 0, dialog, store.hide);
    }, [mounted, domReady, shouldDisableAccessibilityTree]);
    const getPersistentElementsProp = _5WLTMVVQcjs.useEvent.call(void 0, getPersistentElements);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!domReady)
        return;
      if (!id)
        return;
      if (!open)
        return;
      const { disclosureElement } = store.getState();
      const dialog = ref.current;
      const persistentElements = getPersistentElementsProp() || [];
      const allElements = [
        dialog,
        ...persistentElements,
        ...nestedDialogs.map((dialog2) => dialog2.getState().contentElement)
      ];
      if (!shouldDisableAccessibilityTree) {
        return _HTEAWNBYcjs.markTreeOutside.call(void 0, id, disclosureElement, ...allElements);
      }
      if (modal) {
        return _misc.chain.call(void 0, 
          _HTEAWNBYcjs.markTreeOutside.call(void 0, id, ...allElements),
          _CHVOMF22cjs.disableTreeOutside.call(void 0, ...allElements)
        );
      }
      return _misc.chain.call(void 0, 
        _HTEAWNBYcjs.markTreeOutside.call(void 0, id, disclosureElement, ...allElements),
        _FA3DXDDTcjs.disableAccessibilityTreeOutside.call(void 0, ...allElements)
      );
    }, [
      domReady,
      id,
      open,
      store,
      getPersistentElementsProp,
      nestedDialogs,
      shouldDisableAccessibilityTree,
      modal
    ]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const autoFocusOnShowProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, autoFocusOnShow);
    const [autoFocusEnabled, setAutoFocusEnabled] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      if (!mayAutoFocusOnShow)
        return;
      if (!domReady)
        return;
      if (!(contentElement == null ? void 0 : contentElement.isConnected))
        return;
      const element = getElementFromProp(initialFocus, true) || // If no initial focus is specified, we try to focus the first element
      // with the autofocus attribute. If it's an Ariakit component, the
      // Focusable component will consume the autoFocus prop and add the
      // data-autofocus attribute to the element instead.
      contentElement.querySelector(
        "[data-autofocus=true],[autofocus]"
      ) || // We have to fallback to the first focusable element otherwise portaled
      // dialogs with preserveTabOrder set to true will not receive focus
      // properly because the elements aren't tabbable until the dialog
      // receives focus.
      _focus.getFirstTabbableIn.call(void 0, contentElement, true, portal && preserveTabOrder) || // Finally, we fallback to the dialog element itself.
      contentElement;
      const isElementFocusable = _focus.isFocusable.call(void 0, element);
      if (!autoFocusOnShowProp(isElementFocusable ? element : null))
        return;
      setAutoFocusEnabled(true);
      queueMicrotask(() => {
        element.focus();
        if (!isSafariBrowser)
          return;
        element.scrollIntoView({ block: "nearest", inline: "nearest" });
      });
    }, [
      open,
      mayAutoFocusOnShow,
      domReady,
      contentElement,
      initialFocus,
      portal,
      preserveTabOrder,
      autoFocusOnShowProp
    ]);
    const mayAutoFocusOnHide = !!autoFocusOnHide;
    const autoFocusOnHideProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, autoFocusOnHide);
    const [hasOpened, setHasOpened] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      setHasOpened(true);
      return () => setHasOpened(false);
    }, [open]);
    const focusOnHide = _react.useCallback.call(void 0, 
      (dialog, retry = true) => {
        const { open: open2, disclosureElement } = store.getState();
        if (open2)
          return;
        if (isAlreadyFocusingAnotherElement(dialog))
          return;
        let element = getElementFromProp(finalFocus) || disclosureElement;
        if (element == null ? void 0 : element.id) {
          const doc = _dom.getDocument.call(void 0, element);
          const selector = `[aria-activedescendant="${element.id}"]`;
          const composite = doc.querySelector(selector);
          if (composite) {
            element = composite;
          }
        }
        if (element && !_focus.isFocusable.call(void 0, element)) {
          const maybeParentDialog = _dom.closest.call(void 0, element, "[data-dialog]");
          if (maybeParentDialog && maybeParentDialog.id) {
            const doc = _dom.getDocument.call(void 0, maybeParentDialog);
            const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
            const control = doc.querySelector(selector);
            if (control) {
              element = control;
            }
          }
        }
        const isElementFocusable = element && _focus.isFocusable.call(void 0, element);
        if (!isElementFocusable && retry) {
          requestAnimationFrame(() => focusOnHide(dialog, false));
          return;
        }
        if (!autoFocusOnHideProp(isElementFocusable ? element : null))
          return;
        if (!isElementFocusable)
          return;
        element == null ? void 0 : element.focus();
      },
      [store, finalFocus, autoFocusOnHideProp]
    );
    _react.useEffect.call(void 0, () => {
      if (open)
        return;
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      focusOnHide(dialog);
    }, [open, hasOpened, mayAutoFocusOnHide, focusOnHide]);
    _react.useEffect.call(void 0, () => {
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      return () => focusOnHide(dialog);
    }, [hasOpened, mayAutoFocusOnHide, focusOnHide]);
    const hideOnEscapeProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, hideOnEscape);
    _react.useEffect.call(void 0, () => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      const onKeyDown = (event) => {
        if (event.key !== "Escape")
          return;
        if (event.defaultPrevented)
          return;
        const dialog = ref.current;
        if (!dialog)
          return;
        if (_HTEAWNBYcjs.isElementMarked.call(void 0, dialog))
          return;
        const target = event.target;
        if (!target)
          return;
        const { disclosureElement } = store.getState();
        const isValidTarget = () => {
          if (target.tagName === "BODY")
            return true;
          if (_dom.contains.call(void 0, dialog, target))
            return true;
          if (!disclosureElement)
            return false;
          if (_dom.contains.call(void 0, disclosureElement, target))
            return true;
          return false;
        };
        if (!isValidTarget())
          return;
        if (!hideOnEscapeProp(event))
          return;
        store.hide();
      };
      return _events.addGlobalEventListener.call(void 0, "keydown", onKeyDown);
    }, [mounted, domReady, store, hideOnEscapeProp]);
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _SOPRUU56cjs.HeadingLevel, { level: modal ? 1 : void 0, children: element }),
      [modal]
    );
    const hiddenProp = props.hidden;
    const alwaysVisible = props.alwaysVisible;
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        if (!backdrop)
          return element;
        return /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _TUSNAJ32cjs.DialogBackdrop,
            {
              store,
              backdrop,
              backdropProps,
              hidden: hiddenProp,
              alwaysVisible
            }
          ),
          element
        ] });
      },
      [store, backdrop, backdropProps, hiddenProp, alwaysVisible]
    );
    const [headingId, setHeadingId] = _react.useState.call(void 0, );
    const [descriptionId, setDescriptionId] = _react.useState.call(void 0, );
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogContext.Provider, { value: store, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogHeadingContext.Provider, { value: setHeadingId, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogDescriptionContext.Provider, { value: setDescriptionId, children: element }) }) }),
      [store]
    );
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      id,
      "data-dialog": "",
      role: "dialog",
      tabIndex: focusable ? -1 : void 0,
      "aria-labelledby": headingId,
      "aria-describedby": descriptionId
    }, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, props.ref)
    });
    props = _G6F4DPHMcjs.useFocusableContainer.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), {
      autoFocusOnShow: autoFocusEnabled
    }));
    props = _SZTCN3SGcjs.useDisclosureContent.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { store }, props));
    props = _I4JDDV3Vcjs.useFocusable.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), { focusable }));
    props = _YPXV3X22cjs.usePortal.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { portal }, props), { portalRef, preserveTabOrder }));
    return props;
  }
);
var Dialog = _CWY2PHPRcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useDialog(props);
  return _CWY2PHPRcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Dialog.displayName = "Dialog";
}




exports.useDialog = useDialog; exports.Dialog = Dialog;
